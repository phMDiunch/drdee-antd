# Payment QR Code - Dual Bank Accounts

> **STATUS**: üöß IN PROGRESS | **Base**: `010 Payment.md` | **Updated**: 2025-12-28

## M·ª•c ti√™u

M·ªói c∆° s·ªü c√≥ 2 t√†i kho·∫£n ng√¢n h√†ng ri√™ng (C√¥ng ty & C√° nh√¢n), t·ª± ƒë·ªông ch·ªçn QR ph√π h·ª£p d·ª±a tr√™n lo·∫°i d·ªãch v·ª•.

**Logic ch·ªçn t√†i kho·∫£n**: C√≥ √≠t nh·∫•t 1 d·ªãch v·ª• PERSONAL ‚Üí d√πng TK c√° nh√¢n, ng∆∞·ª£c l·∫°i ‚Üí TK c√¥ng ty

**Flow 2 b∆∞·ªõc**:

1. Thu ng√¢n nh·∫≠p ‚Üí System t·∫°o QR ‚Üí Kh√°ch qu√©t thanh to√°n
2. Thu ng√¢n x√°c nh·∫≠n ti·ªÅn v·ªÅ ‚Üí Ghi nh·∫≠n phi·∫øu thu

---

## 1. Database Changes

### Clinic Model

```prisma
model Clinic {
  companyBankName         String? // Ng√¢n h√†ng c√¥ng ty
  companyBankAccountNo    String? // S·ªë TK c√¥ng ty
  companyBankAccountName  String? // T√™n ch·ªß TK c√¥ng ty

  personalBankName        String? // Ng√¢n h√†ng c√° nh√¢n
  personalBankAccountNo   String? // S·ªë TK c√° nh√¢n
  personalBankAccountName String? // T√™n ch·ªß TK c√° nh√¢n
}
```

### PaymentVoucher Model

```prisma
model PaymentVoucher {
  accountTypeUsed String? // "COMPANY" | "PERSONAL" - track t√†i kho·∫£n ƒë√£ d√πng
}
```

**Migration**:

```bash
prisma migrate dev --name add_clinic_dual_bank_accounts
```

**Validation Strategy**:

```
Database (Prisma):
  ‚îî‚îÄ All 6 fields nullable (no constraints)

Schema (Zod):
  ‚îú‚îÄ CreateClinicRequestSchema: All 6 fields REQUIRED
  ‚îú‚îÄ UpdateClinicRequestSchema: All fields partial (optional but validated if provided)
  ‚îî‚îÄ ClinicResponseSchema: All fields nullable (backward compatible)

Application:
  ‚îú‚îÄ Frontend: zodResolver auto-validates form with CreateClinicRequestSchema
  ‚îú‚îÄ Backend API: Auto-validates requests with schema before hitting DB
  ‚îî‚îÄ Payment Creation: Blocks if clinic missing required account
```

---

## 2. Shared Utilities

**File**: `src/shared/constants/payment.ts`

### Types & Helpers

```typescript
export type BankConfig = {
  bankName: string;
  accountNumber: string;
  accountName: string;
};

// X√°c ƒë·ªãnh lo·∫°i TK d·ª±a tr√™n d·ªãch v·ª•
export function determinePaymentAccountType(
  services: Array<{
    dentalService: { paymentAccountType: "COMPANY" | "PERSONAL" };
  }>
): "COMPANY" | "PERSONAL" {
  const hasPersonal = services.some(
    (s) => s.dentalService.paymentAccountType === "PERSONAL"
  );
  return hasPersonal ? "PERSONAL" : "COMPANY";
}

// Convert Clinic sang BankConfig
export function clinicToBankConfig(
  clinic: {
    companyBankName?: string | null;
    companyBankAccountNo?: string | null;
    companyBankAccountName?: string | null;
    personalBankName?: string | null;
    personalBankAccountNo?: string | null;
    personalBankAccountName?: string | null;
  },
  accountType: "COMPANY" | "PERSONAL"
): BankConfig | undefined {
  if (accountType === "COMPANY") {
    if (
      !clinic.companyBankName ||
      !clinic.companyBankAccountNo ||
      !clinic.companyBankAccountName
    )
      return undefined;
    return {
      bankName: clinic.companyBankName,
      accountNumber: clinic.companyBankAccountNo,
      accountName: clinic.companyBankAccountName,
    };
  } else {
    if (
      !clinic.personalBankName ||
      !clinic.personalBankAccountNo ||
      !clinic.personalBankAccountName
    )
      return undefined;
    return {
      bankName: clinic.personalBankName,
      accountNumber: clinic.personalBankAccountNo,
      accountName: clinic.personalBankAccountName,
    };
  }
}

// Generate SePay QR URL
export function generateVietQRUrl(
  amount: number,
  description: string,
  bankConfig: BankConfig
): string {
  const baseUrl = "https://qr.sepay.vn/img";
  const params = new URLSearchParams({
    bank: bankConfig.bankName,
    acc: bankConfig.accountNumber,
    template: "qronly",
    amount: amount.toString(),
    des: description,
  });
  return `${baseUrl}?${params.toString()}`;
}
```

---

## 3. Schema Validation

**File**: `src/shared/validation/clinic.schema.ts`

```typescript
// Add bank fields directly to ClinicBaseSchema
export const ClinicBaseSchema = z.object({
  clinicCode: z.string().trim().min(1, "M√£ ph√≤ng kh√°m l√† b·∫Øt bu·ªôc"),
  name: z.string().trim().min(1, "T√™n ph√≤ng kh√°m l√† b·∫Øt bu·ªôc"),
  shortName: z
    .string()
    .trim()
    .min(1, "T√™n vi·∫øt t·∫Øt l√† b·∫Øt bu·ªôc")
    .max(20, "T√™n vi·∫øt t·∫Øt kh√¥ng qu√° 20 k√Ω t·ª±"),
  address: z.string().trim().min(1, "ƒê·ªãa ch·ªâ l√† b·∫Øt bu·ªôc"),
  phone: z
    .string()
    .trim()
    .regex(VN_PHONE_RE, "S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ª£p l·ªá")
    .optional()
    .nullable(),
  email: z.string().trim().email("Email kh√¥ng h·ª£p l·ªá").optional().nullable(),
  colorCode: z.string().trim().regex(HEX6_RE, "M√£ m√†u l√† b·∫Øt bu·ªôc"),
  archivedAt: z.date().optional().nullable(),

  // Company Bank Account - Required
  companyBankName: z
    .string()
    .trim()
    .min(1, "T√™n ng√¢n h√†ng c√¥ng ty l√† b·∫Øt bu·ªôc"),
  companyBankAccountNo: z
    .string()
    .trim()
    .min(1, "S·ªë t√†i kho·∫£n c√¥ng ty l√† b·∫Øt bu·ªôc"),
  companyBankAccountName: z
    .string()
    .trim()
    .min(1, "T√™n ch·ªß TK c√¥ng ty l√† b·∫Øt bu·ªôc"),

  // Personal Bank Account - Required
  personalBankName: z
    .string()
    .trim()
    .min(1, "T√™n ng√¢n h√†ng c√° nh√¢n l√† b·∫Øt bu·ªôc"),
  personalBankAccountNo: z
    .string()
    .trim()
    .min(1, "S·ªë t√†i kho·∫£n c√° nh√¢n l√† b·∫Øt bu·ªôc"),
  personalBankAccountName: z
    .string()
    .trim()
    .min(1, "T√™n ch·ªß TK c√° nh√¢n l√† b·∫Øt bu·ªôc"),
});

// Create Schema: All fields required (omit archivedAt only)
export const CreateClinicRequestSchema = ClinicBaseSchema.omit({
  archivedAt: true,
});

// Update Schema: All fields optional
export const UpdateClinicRequestSchema = ClinicBaseSchema.extend({
  id: z.string().uuid("ID kh√¥ng h·ª£p l·ªá"),
});

// Response Schema: All fields nullable for backward compatibility
export const ClinicResponseSchema = z.object({
  id: z.string().uuid(),
  clinicCode: z.string(),
  name: z.string(),
  shortName: z.string(),
  address: z.string(),
  phone: z.string().nullable().optional(),
  email: z.string().nullable().optional(),
  colorCode: z.string(),

  // Bank fields (nullable for old data without bank info)
  companyBankName: z.string().nullable().optional(),
  companyBankAccountNo: z.string().nullable().optional(),
  companyBankAccountName: z.string().nullable().optional(),
  personalBankName: z.string().nullable().optional(),
  personalBankAccountNo: z.string().nullable().optional(),
  personalBankAccountName: z.string().nullable().optional(),

  archivedAt: z.string().datetime().nullable().optional(),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
});
```

**Validation Flow**:

- **Create**: T·∫•t c·∫£ 6 bank fields b·∫Øt bu·ªôc (required trong ClinicBaseSchema)
- **Update**: T·∫•t c·∫£ fields optional (theo pattern hi·ªán t·∫°i c·ªßa UpdateClinicRequestSchema)
- **Response**: Nullable ƒë·ªÉ support old clinics ch∆∞a c√≥ bank info

**Note**: Theo pattern hi·ªán t·∫°i c·ªßa project, kh√¥ng d√πng `.merge()` - add fields tr·ª±c ti·∫øp v√†o ClinicBaseSchema.

**File**: `src/shared/validation/payment-voucher.schema.ts`

```typescript
export const PaymentVoucherResponseSchema = z.object({
  // ... existing fields ...
  accountTypeUsed: z.enum(["COMPANY", "PERSONAL"]).nullable(),
});
```

---

## 4. Clinic Management UI

**File**: `src/features/clinics/components/ClinicFormModal.tsx`

### Form Fields

```tsx
{/* Company Account */}
<Col xs={24}>
  <Divider orientation="left">
    <Space>
      <Tag color="gold">üè¢ T√†i kho·∫£n c√¥ng ty</Tag>
      <Text type="secondary" style={{fontSize: 12}}>(cho d·ªãch v·ª• thu v·ªÅ c√¥ng ty)</Text>
    </Space>
  </Divider>
</Col>

<Col xs={24} lg={8}>
  <Controller name="companyBankName" control={control}
    render={({ field, fieldState }) => (
      <Form.Item label="T√™n ng√¢n h√†ng" validateStatus={fieldState.error ? "error" : ""}
        help={fieldState.error?.message} required>
        <Input {...field} placeholder="VD: BIDV, VCB..." maxLength={50} />
      </Form.Item>
    )} />
</Col>
<Col xs={24} lg={8}>
  <Controller name="companyBankAccountNo" control={control}
    render={({ field, fieldState }) => (
      <Form.Item label="S·ªë t√†i kho·∫£n" validateStatus={fieldState.error ? "error" : ""}
        help={fieldState.error?.message} required>
        <Input {...field} placeholder="VD: 2610143271" maxLength={30} />
      </Form.Item>
    )} />
</Col>
<Col xs={24} lg={8}>
  <Controller name="companyBankAccountName" control={control}
    render={({ field, fieldState }) => (
      <Form.Item label="T√™n ch·ªß TK" validateStatus={fieldState.error ? "error" : ""}
        help={fieldState.error?.message} required>
        <Input {...field} placeholder="VD: CONG TY ABC" maxLength={100}
          style={{textTransform: "uppercase"}} />
      </Form.Item>
    )} />
</Col>

{/* Personal Account - Similar structure */}
<Col xs={24}>
  <Divider orientation="left">
    <Space>
      <Tag color="blue">üë§ T√†i kho·∫£n c√° nh√¢n</Tag>
      <Text type="secondary" style={{fontSize: 12}}>(cho d·ªãch v·ª• thu v·ªÅ c√° nh√¢n)</Text>
    </Space>
  </Divider>
</Col>
{/* ... 3 fields t∆∞∆°ng t·ª± ... */}
```

### Form Setup

```typescript
const form = useForm<CreateClinicRequest>({
  resolver: zodResolver(CreateClinicRequestSchema), // Auto-validates all 6 bank fields as required
  defaultValues: {
    // ... existing fields (clinicCode, name, address, phone, email, colorCode) ...

    // Bank info - Required by schema
    companyBankName: "",
    companyBankAccountNo: "",
    companyBankAccountName: "",
    personalBankName: "",
    personalBankAccountNo: "",
    personalBankAccountName: "",
  },
});

// No custom validation needed - Zod schema handles all validation
// Form will show errors automatically if fields are empty on submit
```

---

## 5. QR Payment Component

**File**: `src/shared/components/QRPayment.tsx`

```typescript
interface QRPaymentProps {
  amount: number;
  voucherCode: string;
  bankConfig: BankConfig; // Required - no fallback
  accountType: "COMPANY" | "PERSONAL";
  size?: number;
  showLabel?: boolean;
}

export default function QRPayment({
  amount,
  voucherCode,
  bankConfig,
  accountType,
  size = 100,
  showLabel = false,
}: QRPaymentProps) {
  const qrUrl = generateVietQRUrl(amount, voucherCode, bankConfig);

  return (
    <div
      style={{
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        gap: "4px",
      }}
    >
      <img
        src={qrUrl}
        alt={`QR thanh to√°n ${voucherCode}`}
        style={{
          width: size,
          height: size,
          border: "1px solid #d9d9d9",
          borderRadius: "4px",
        }}
      />

      {showLabel && (
        <div
          style={{
            fontSize: "10px",
            color: "#666",
            textAlign: "center",
            lineHeight: "1.2",
          }}
        >
          <div style={{ fontWeight: 500 }}>Qu√©t m√£ thanh to√°n</div>
          <Tag
            color={accountType === "COMPANY" ? "gold" : "blue"}
            style={{ marginTop: 4 }}
          >
            {accountType === "COMPANY" ? "üè¢ C√¥ng ty" : "üë§ C√° nh√¢n"}
          </Tag>
          <div>{bankConfig.accountName}</div>
        </div>
      )}
    </div>
  );
}
```

---

## 6. Two-Step Payment Flow

### Step 1: Create Payment Draft & Generate QR

**Component**: `CreatePaymentVoucherModal.tsx`

#### State Management

```typescript
const [paymentDraft, setPaymentDraft] = useState<{
  customerId: string;
  customerName: string;
  totalAmount: number;
  details: SelectedService[];
  notes?: string;
  tempCode: string;
  accountType: "COMPANY" | "PERSONAL";
} | null>(null);

const [showQRModal, setShowQRModal] = useState(false);
```

#### Generate QR Handler

```typescript
const handleGenerateQR = async () => {
  try {
    // 1. Validate form
    const values = await form.validateFields();

    // 2. Load consulted services with dentalService info
    const fullServices = await loadConsultedServicesWithDentalService(
      selectedServices
    );

    // 3. Determine account type
    const accountType = determinePaymentAccountType(fullServices);

    // 4. Get clinic bank config
    const bankConfig = clinicToBankConfig(currentClinic, accountType);

    // 5. Validate clinic has required account
    if (!bankConfig) {
      Modal.error({
        title: "Thi·∫øu th√¥ng tin t√†i kho·∫£n",
        content: (
          <p>
            C∆° s·ªü ch∆∞a c·∫•u h√¨nh t√†i kho·∫£n{" "}
            <Tag color={accountType === "COMPANY" ? "gold" : "blue"}>
              {accountType === "COMPANY" ? "üè¢ C√¥ng ty" : "üë§ C√° nh√¢n"}
            </Tag>{" "}
            c·∫ßn thi·∫øt.
          </p>
        ),
      });
      return;
    }

    // 6. Generate temp code
    const tempCode = `TMP-${currentClinic.clinicCode}-${Date.now()
      .toString()
      .slice(-10)}`;

    // 7. Save draft
    setPaymentDraft({
      customerId: values.customerId,
      customerName: selectedCustomer.fullName,
      totalAmount: calculateTotal(selectedServices),
      details: fullServices,
      notes: values.notes,
      tempCode,
      accountType,
    });

    // 8. Show QR modal
    setShowQRModal(true);
  } catch (error) {
    message.error("L·ªói t·∫°o m√£ QR: " + error.message);
  }
};
```

#### Button

```tsx
<Button type="primary" icon={<QrcodeOutlined />} onClick={handleGenerateQR}>
  T·∫°o m√£ QR thanh to√°n
</Button>
```

### Step 2: Display QR & Confirm Payment

**New Component**: `PaymentQRConfirmModal.tsx`

```typescript
interface PaymentQRConfirmModalProps {
  open: boolean;
  draft: {
    customerId: string;
    customerName: string;
    totalAmount: number;
    details: SelectedService[];
    notes?: string;
    tempCode: string;
    accountType: "COMPANY" | "PERSONAL";
  } | null;
  clinic: {
    companyBankName?: string;
    companyBankAccountNo?: string;
    companyBankAccountName?: string;
    personalBankName?: string;
    personalBankAccountNo?: string;
    personalBankAccountName?: string;
  };
  confirmLoading?: boolean;
  onCancel: () => void;
  onConfirm: (
    payload: CreatePaymentVoucherRequest,
    accountType: "COMPANY" | "PERSONAL"
  ) => void;
}
```

#### Modal Layout

```tsx
<Modal
  open={open}
  width="70%"
  title={
    <Space>
      <QrcodeOutlined />
      Qu√©t m√£ thanh to√°n
      <Tag color={draft?.accountType === "COMPANY" ? "gold" : "blue"}>
        {draft?.accountType === "COMPANY" ? "üè¢ C√¥ng ty" : "üë§ C√° nh√¢n"}
      </Tag>
    </Space>
  }
  footer={[
    <Button key="cancel" onClick={handleCancel}>
      H·ªßy thanh to√°n
    </Button>,
    <Button
      key="confirm"
      type="primary"
      icon={<CheckCircleOutlined />}
      loading={confirmLoading}
      onClick={handleConfirm}
    >
      ‚úì X√°c nh·∫≠n ƒë√£ nh·∫≠n ti·ªÅn
    </Button>,
  ]}
  onCancel={handleCancel}
  maskClosable={false}
  destroyOnClose
>
  <Space direction="vertical" size="large" style={{ width: "100%" }}>
    {/* Account Type Alert */}
    <Alert
      type="info"
      showIcon
      message={
        <span>
          Phi·∫øu thu n√†y s·∫Ω thanh to√°n v√†o t√†i kho·∫£n:
          <Tag color={draft?.accountType === "COMPANY" ? "gold" : "blue"}>
            {draft?.accountType === "COMPANY" ? "üè¢ C√¥ng ty" : "üë§ C√° nh√¢n"}
          </Tag>
        </span>
      }
      description={
        draft?.accountType === "PERSONAL"
          ? "C√≥ √≠t nh·∫•t 1 d·ªãch v·ª• thu v·ªÅ c√° nh√¢n trong phi·∫øu thu n√†y."
          : "T·∫•t c·∫£ d·ªãch v·ª• trong phi·∫øu thu ƒë·ªÅu thu v·ªÅ c√¥ng ty."
      }
    />

    {/* QR Code */}
    <div
      style={{
        textAlign: "center",
        padding: 24,
        background: "#fafafa",
        borderRadius: 8,
      }}
    >
      <QRPayment
        amount={draft?.totalAmount || 0}
        voucherCode={draft?.tempCode || ""}
        bankConfig={bankConfig}
        accountType={draft?.accountType || "COMPANY"}
        size={200}
        showLabel={true}
      />
    </div>

    {/* Bank Info */}
    <Card size="small" title="üì± Th√¥ng tin chuy·ªÉn kho·∫£n">
      <Descriptions column={1} size="small">
        <Descriptions.Item label="Lo·∫°i t√†i kho·∫£n">
          <Tag color={draft?.accountType === "COMPANY" ? "gold" : "blue"}>
            {draft?.accountType === "COMPANY" ? "üè¢ C√¥ng ty" : "üë§ C√° nh√¢n"}
          </Tag>
        </Descriptions.Item>
        <Descriptions.Item label="Ng√¢n h√†ng">
          {bankConfig.bankName}
        </Descriptions.Item>
        <Descriptions.Item label="S·ªë t√†i kho·∫£n">
          <Text copyable>{bankConfig.accountNumber}</Text>
        </Descriptions.Item>
        <Descriptions.Item label="Ch·ªß t√†i kho·∫£n">
          {bankConfig.accountName}
        </Descriptions.Item>
        <Descriptions.Item label="S·ªë ti·ªÅn">
          <Text strong style={{ fontSize: 18, color: "#1890ff" }}>
            {formatCurrency(draft?.totalAmount || 0)}
          </Text>
        </Descriptions.Item>
        <Descriptions.Item label="N·ªôi dung">
          <Text code>{draft?.tempCode}</Text>
        </Descriptions.Item>
      </Descriptions>
    </Card>

    {/* Payment Summary */}
    <Card size="small" title="Th√¥ng tin thanh to√°n">
      <Descriptions column={2} size="small">
        <Descriptions.Item label="Kh√°ch h√†ng" span={2}>
          {draft?.customerName}
        </Descriptions.Item>
        <Descriptions.Item label="S·ªë d·ªãch v·ª•">
          {draft?.details.length}
        </Descriptions.Item>
        <Descriptions.Item label="T·ªïng ti·ªÅn">
          {formatCurrency(draft?.totalAmount || 0)}
        </Descriptions.Item>
      </Descriptions>

      {/* Service List with Account Type */}
      <div style={{ marginTop: 12 }}>
        <Text type="secondary">D·ªãch v·ª• thanh to√°n:</Text>
        <ul style={{ marginTop: 8 }}>
          {draft?.details.map((detail, idx) => (
            <li key={idx}>
              <Tag
                color={
                  detail.dentalService.paymentAccountType === "COMPANY"
                    ? "gold"
                    : "blue"
                }
                style={{ fontSize: 10 }}
              >
                {detail.dentalService.paymentAccountType === "COMPANY"
                  ? "üè¢"
                  : "üë§"}
              </Tag>
              {detail.serviceName}: {formatCurrency(detail.amount)}({
                getPaymentMethodConfig(detail.paymentMethod).label
              })
            </li>
          ))}
        </ul>
      </div>
    </Card>

    {/* Warning */}
    <Alert
      type="warning"
      showIcon
      message="‚ö†Ô∏è L∆∞u √Ω quan tr·ªçng"
      description={
        <div>
          <p>
            Vui l√≤ng ki·ªÉm tra k·ªπ ti·ªÅn ƒë√£ v·ªÅ{" "}
            <strong>
              t√†i kho·∫£n{" "}
              {draft?.accountType === "COMPANY" ? "c√¥ng ty" : "c√° nh√¢n"}
            </strong>{" "}
            tr∆∞·ªõc khi nh·∫•n n√∫t X√°c nh·∫≠n.
          </p>
          <p>Sau khi x√°c nh·∫≠n, phi·∫øu thu s·∫Ω ƒë∆∞·ª£c t·∫°o v√† ƒë·ªìng b·ªô c√¥ng n·ª£.</p>
        </div>
      }
    />
  </Space>
</Modal>
```

#### Handlers

```typescript
const handleConfirm = () => {
  if (!draft) return;

  const payload: CreatePaymentVoucherRequest = {
    customerId: draft.customerId,
    details: draft.details.map((d) => ({
      consultedServiceId: d.consultedServiceId,
      amount: d.amount,
      paymentMethod: d.paymentMethod,
      consultedServiceName: d.serviceName,
    })),
    notes: draft.notes,
  };

  onConfirm(payload, draft.accountType);
};

const handleCancel = () => {
  Modal.confirm({
    title: "H·ªßy thanh to√°n?",
    content: "B·∫°n c√≥ ch·∫Øc mu·ªën h·ªßy? D·ªØ li·ªáu ƒë√£ nh·∫≠p s·∫Ω kh√¥ng ƒë∆∞·ª£c l∆∞u.",
    okText: "ƒê·ªìng √Ω",
    cancelText: "Quay l·∫°i",
    onOk: () => onCancel(),
  });
};
```

---

## 7. Backend Service

**File**: `src/server/services/payment-voucher.service.ts`

```typescript
export const paymentVoucherService = {
  async create(
    currentUser: UserCore | null,
    body: unknown,
    accountType: "COMPANY" | "PERSONAL"
  ) {
    // ... existing validation ...

    const data: PaymentVoucherCreateInput = {
      ...parsed,
      paymentNumber: "", // Generated in repo
      paymentDate: new Date(),
      totalAmount,
      cashierId: currentUser!.employeeId!,
      clinicId,
      accountTypeUsed: accountType, // Store which account was used
      createdById: currentUser!.employeeId!,
      updatedById: currentUser!.employeeId!,
    };

    const created = await paymentVoucherRepo.create(data);
    return PaymentVoucherResponseSchema.parse(
      mapPaymentVoucherToResponse(created)
    );
  },
};
```

**File**: `src/server/actions/payment-voucher.actions.ts`

```typescript
export async function createPaymentVoucher(
  body: unknown,
  accountType: "COMPANY" | "PERSONAL"
) {
  const user = await getCurrentUserCore();
  const result = await paymentVoucherService.create(user, body, accountType);
  return result;
}
```

---

## 8. Receipt Printing

**File**: `src/features/payments/components/PrintableReceipt.tsx`

```tsx
interface Props {
  voucher: PaymentVoucherResponse;
  clinicInfo?: {
    name: string;
    address: string;
    phone: string;
    logo?: string;
    // Bank info based on accountTypeUsed
    bankName?: string;
    bankAccountNo?: string;
    bankAccountName?: string;
  };
}

// In component
const bankConfig =
  clinicInfo?.bankName &&
  clinicInfo?.bankAccountNo &&
  clinicInfo?.bankAccountName
    ? {
        bankName: clinicInfo.bankName,
        accountNumber: clinicInfo.bankAccountNo,
        accountName: clinicInfo.bankAccountName,
      }
    : undefined;

// In render
{
  copyLabel === "LI√äN 2" && bankConfig && (
    <QRPayment
      amount={voucher.totalAmount || 0}
      voucherCode={voucher.paymentNumber}
      size={60}
      bankConfig={bankConfig}
      accountType={voucher.accountTypeUsed || "COMPANY"}
    />
  );
}
```

---

## 9. Testing Checklist

### Database & Migration

- [ ] Migration adds 6 nullable fields to Clinic
- [ ] Migration adds accountTypeUsed to PaymentVoucher
- [ ] Old clinics load with null bank fields (backward compatible)
- [ ] Seed data with bank info for testing

### Schema Validation

- [ ] Create Clinic without bank info ‚Üí Zod error (6 required_error messages)
- [ ] Create Clinic with only company account ‚Üí Zod error (3 personal fields missing)
- [ ] Create Clinic with only personal account ‚Üí Zod error (3 company fields missing)
- [ ] Create Clinic with empty strings ‚Üí Zod error (min length validation)
- [ ] Create Clinic with all 6 fields valid ‚Üí Success ‚úÖ
- [ ] Update Clinic partial (no bank fields) ‚Üí Success (partial schema)
- [ ] Update Clinic partial (with bank fields) ‚Üí Validates provided fields only
- [ ] Backend API rejects invalid requests (Zod validation at service layer)
- [ ] Old clinics load successfully (Response schema nullable)

### Clinic Management

- [ ] Form requires all 6 bank fields
- [ ] Submit shows validation errors per field
- [ ] Edit existing clinic pre-fills bank info
- [ ] Update validates all 6 fields

### Account Determination Logic

- [ ] All COMPANY services ‚Üí Use company account
- [ ] Has PERSONAL service ‚Üí Use personal account
- [ ] Missing required account ‚Üí Shows error, blocks payment

### Two-Step Payment Flow

- [ ] Button "T·∫°o m√£ QR thanh to√°n" works
- [ ] QR modal shows correct account type (tag color)
- [ ] QR code scannable and auto-fills correctly
- [ ] Confirm creates payment with accountTypeUsed
- [ ] Cancel shows confirmation, can go back to edit
- [ ] Debt syncs correctly after confirm

### Receipt Printing

- [ ] Receipt shows QR with correct account
- [ ] Old receipts (null accountTypeUsed) still print

### Edge Cases

- [ ] Clinic missing required account ‚Üí Error message clear
- [ ] QR modal cancel ‚Üí Confirmation dialog works
- [ ] Network error on confirm ‚Üí Proper error handling
- [ ] Mobile responsive for QR modal

---

## 10. Implementation Phases

### Phase 1: Database (30 min)

- [ ] Create & run migration for Clinic + PaymentVoucher
- [ ] Update schema files
- [ ] Test migration on dev DB

### Phase 2: Shared Utilities (1 hour)

- [ ] Add types & helpers to payment.ts
- [ ] Update QRPayment component
- [ ] Update schema validation
- [ ] Write unit tests

### Phase 3: Clinic Management (1.5 hours)

- [ ] Add bank info fields to ClinicFormModal
- [ ] Update defaultValues
- [ ] Use zodResolver - no custom validation needed
- [ ] Test create/edit flows

### Phase 4: Two-Step Flow (3 hours)

- [ ] Refactor CreatePaymentVoucherModal
- [ ] Create PaymentQRConfirmModal
- [ ] Update parent state management
- [ ] Test complete flow

### Phase 5: Backend (1 hour)

- [ ] Update payment-voucher.service
- [ ] Update server actions
- [ ] Test API integration

### Phase 6: Receipt & Testing (1 hour)

- [ ] Update PrintableReceipt
- [ ] Full end-to-end testing
- [ ] Fix bugs

**Total Estimate**: ~8 hours

---

## 11. Important Notes

### Post-Migration Actions

- Admin must update bank info for existing clinics via Clinic Management
- Consider seed script to populate default bank info
- Consider bulk import tool if many clinics

### Data Migration

Existing clinics will have null bank fields ‚Üí Valid in database, but:

- **Payment Creation**: System blocks if clinic missing required account (runtime check)
- **Clinic Create/Update**: Schema validation (Zod) requires all 6 fields
- **Old Data Loading**: Response schema nullable - backward compatible

**Three-Layer Validation**:

1. **Database**: No constraints (flexible storage)
2. **Schema (Zod)**: Required on create, partial on update (strong validation)
3. **Runtime**: Payment flow checks account availability before generating QR

### Color Coding

- üü° Company: Gold `#faad14`
- üîµ Personal: Blue `#1890ff`

### Security

- Bank info is sensitive ‚Üí Only admin can view/edit
- Consider audit log for bank info changes

---

## Success Criteria

‚úÖ Each clinic has 2 separate bank accounts in DB  
‚úÖ QR code generated per clinic-specific bank info  
‚úÖ Account type auto-determined from service types  
‚úÖ Payment flow clear 2-step: Generate QR ‚Üí Confirm  
‚úÖ Track accountTypeUsed for audit  
‚úÖ Backward compatible with old payments  
‚úÖ No breaking changes

---

**END OF REQUIREMENTS**
