# üîÑ Phase 0.1.3: ConsultedService Refactor for Deal-Centric Tracking

> **Date**: 2025-12-15  
> **Status**: üìù PLANNING - Comprehensive refactor for deal-centric CRM  
> **Parent**: 119 FINAL Implementation Plan  
> **Dependencies**: 120.1 Customer Updates ‚úÖ COMPLETED  
> **Scope**: Refactor ConsultedService feature to support deal source tracking, pipeline stages, and follow-up system

---

## üìä OVERVIEW

Refactor **ConsultedService feature** (Sales Opportunity/Deal) ƒë·ªÉ h·ªó tr·ª£:

1. ‚úÖ Deal-level source tracking (dynamic campaign attribution)
2. ‚úÖ 2-Phase Pipeline stage management:
   - **Lead Pipeline** (Sale Online): NEW ‚Üí CONTACTING ‚Üí SCHEDULED ‚Üí ARRIVED
   - **Opportunity Pipeline** (Sale Offline): ARRIVED ‚Üí CONSULTING ‚Üí QUOTED ‚Üí DEPOSIT ‚Üí TREATING
   - **End States**: LOST (c√≥ th·ªÉ x·∫£y ra ·ªü b·∫•t k·ª≥ stage n√†o trong c·∫£ 2 phases)
3. ‚úÖ Follow-up scheduling (priority, nextFollowUpDate)
4. ‚úÖ Multiple sales roles (saleOnlineId for telesale, consultingSaleId for offline)
5. ‚úÖ Lost deal tracking (lostReason, lostDate)

**Business Context:**

- ConsultedService = Sales Opportunity/Deal (kh√¥ng ph·∫£i d·ªãch v·ª• ƒë√£ th·ª±c hi·ªán)
- M·ªói deal c√≥ source ri√™ng (kh√°c v·ªõi Customer.source)
- Deal source tracking cho ph√©p t√≠nh ROI theo campaign c·ª• th·ªÉ
- Pipeline stage cho ph√©p visualize deal flow qua Kanban board

---

## üóÑÔ∏è SCHEMA CHANGES

**Reference:** See [119 FINAL - Implementation Plan.md](119%20FINAL%20-%20Implementation%20Plan.md#2-consultedservice-model) for complete schema definition.

### ConsultedService Model Updates

| Field              | Type      | Description                                                                                                                           |
| ------------------ | --------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| `source`           | String    | REQUIRED - Deal source (campaign): "FACEBOOK_ADS_DEC", etc.                                                                           |
| `sourceNotes`      | String?   | Campaign details                                                                                                                      |
| `stage`            | String    | 2-Phase Pipeline stage: NEW/CONTACTING/SCHEDULED/ARRIVED (Lead) ‚Üí CONSULTING/QUOTED/DEPOSIT/TREATING (Opportunity) ‚Üí LOST (End state) |
| `followUpPriority` | String?   | Priority: HIGH/MEDIUM/LOW                                                                                                             |
| `nextFollowUpDate` | DateTime? | Next follow-up date                                                                                                                   |
| `saleOnlineId`     | String?   | Sale Online (telesale) assigned                                                                                                       |
| `lostReason`       | String?   | Reason if stage = LOST (c√≥ th·ªÉ x·∫£y ra ·ªü b·∫•t k·ª≥ phase n√†o)                                                                             |
| `lostDate`         | DateTime? | Date when marked as LOST                                                                                                              |
| `lostAtStage`      | String?   | ‚≠ê Snapshot: Pipeline stage when lost (e.g., "QUOTED", "CONTACTING") - Only set when stage = LOST                                     |
| `wonDate`          | DateTime? | Date when stage = TREATING (= serviceConfirmDate - ng√†y kh√°ch b·∫Øt ƒë·∫ßu ƒëi·ªÅu tr·ªã)                                                       |

**Key Points:**

- Schema migration done in [119 FINAL](119%20FINAL%20-%20Implementation%20Plan.md)
- `source` is REQUIRED (different from Customer.source)
- **Initial Stage Logic** (depends on customer type):
  - If `customer.type = LEAD` ‚Üí `stage = NEW` (Lead Pipeline - need to contact)
  - If `customer.type = CUSTOMER` ‚Üí `stage = ARRIVED` (Opportunity Pipeline - already at clinic)
- **2-Phase Pipeline:**
  - **Phase 1 (Lead)**: NEW ‚Üí CONTACTING ‚Üí SCHEDULED ‚Üí ARRIVED (Sale Online target)
  - **Phase 2 (Opportunity)**: ARRIVED ‚Üí CONSULTING ‚Üí QUOTED ‚Üí DEPOSIT ‚Üí TREATING (Sale Offline/Doctor)
  - **End States**: LOST (c√≥ th·ªÉ x·∫£y ra ·ªü b·∫•t k·ª≥ stage n√†o), TREATING (th√†nh c√¥ng cu·ªëi c√πng)
- `stage` determines active/completed:
  - **Active deals** = NOT IN ('LOST', 'TREATING') - bao g·ªìm DEPOSIT v√¨ c√≥ th·ªÉ h·ªßy
  - **Won deals** = 'TREATING' only - ch·ªâ khi kh√°ch ƒë√£ b·∫Øt ƒë·∫ßu ƒëi·ªÅu tr·ªã
  - **Lost deals** = 'LOST'
- **Important**: DEPOSIT c√≥ th·ªÉ chuy·ªÉn sang LOST (kh√°ch c·ªçc nh∆∞ng sau ƒë√≥ h·ªßy) ho·∫∑c TREATING (b·∫Øt ƒë·∫ßu ƒëi·ªÅu tr·ªã)
- **Lost Tracking**: Khi stage = LOST, `lostAtStage` s·∫Ω l∆∞u pipeline stage tr∆∞·ªõc ƒë√≥ (ƒë·ªÉ bi·∫øt lost ·ªü ƒë√¢u trong pipeline)
- **Won Tracking**: `serviceConfirmDate` ƒë∆∞·ª£c set khi user b·∫•m n√∫t "Ch·ªët" v√† stage = TREATING (ng√†y kh√°ch b·∫Øt ƒë·∫ßu ƒëi·ªÅu tr·ªã)
- Index: `(stage, nextFollowUpDate)` for follow-up queries

---

## üîß BACKEND CHANGES

### 1. Validation Schema Updates (`src/shared/validation/consulted-service.schema.ts`)

#### A. ConsultedServiceCommonFieldsSchema

**Add new fields:**

```typescript
// ‚≠ê NEW: Deal source (required, different from customer source)
source: z.string().trim().min(1, "Vui l√≤ng ch·ªçn ngu·ªìn deal"),
sourceNotes: z.string().trim().optional().nullable(),

// ‚≠ê NEW: 2-Phase Pipeline stage
stage: z.enum([
  // Phase 1: Lead Pipeline (Sale Online)
  "NEW", "CONTACTING", "SCHEDULED", "ARRIVED",
  // Phase 2: Opportunity Pipeline (Sale Offline/Doctor)
  "CONSULTING", "QUOTED", "DEPOSIT", "TREATING",
  // End state (c√≥ th·ªÉ x·∫£y ra ·ªü b·∫•t k·ª≥ phase n√†o)
  "LOST"
]),

// ‚≠ê NEW: Follow-up fields
followUpPriority: z.enum(["HIGH", "MEDIUM", "LOW"]).optional().nullable(),
nextFollowUpDate: z.coerce.date().optional().nullable(),

// ‚≠ê NEW: Multiple sales roles
saleOnlineId: z.string().uuid().optional().nullable(), // Telesale

// ‚≠ê NEW: Lost tracking (for LOST stage - c√≥ th·ªÉ x·∫£y ra ·ªü c·∫£ 2 phases)
lostReason: z.string().trim().optional().nullable(),
lostDate: z.coerce.date().optional().nullable(),
lostAtStage: z.string().trim().optional().nullable(), // Snapshot of stage when lost

// Note: serviceConfirmDate is set when user clicks "Ch·ªët" button (separate logic)

```

#### B. ConsultedServiceCreateRequestSchema

**Required fields:**

```typescript
export const ConsultedServiceCreateRequestSchema = z.object({
  customerId: z.string().uuid("Kh√°ch h√†ng kh√¥ng h·ª£p l·ªá"),
  dentalServiceId: z.string().uuid("D·ªãch v·ª• kh√¥ng h·ª£p l·ªá"),
  source: z.string().trim().min(1, "Vui l√≤ng ch·ªçn ngu·ªìn deal"), // ‚≠ê REQUIRED
  stage: z
    .enum([
      "NEW",
      "CONTACTING",
      "SCHEDULED",
      "ARRIVED",
      "LOST",
      "CONSULTING",
      "QUOTED",
      "DEPOSIT",
      "TREATING",
    ])
    .optional(), // ‚≠ê Stage depends on customer.type: LEAD ‚Üí NEW, CUSTOMER ‚Üí ARRIVED

  // Optional fields
  sourceNotes: z.string().trim().optional().nullable(),
  followUpPriority: z.enum(["HIGH", "MEDIUM", "LOW"]).optional().nullable(),
  nextFollowUpDate: z.coerce.date().optional().nullable(),
  saleOnlineId: z.string().uuid().optional().nullable(),

  // ... existing fields (price, serviceStatus, consultingSaleId, etc.)
});

export type ConsultedServiceCreateRequest = z.infer<
  typeof ConsultedServiceCreateRequestSchema
>;
```

#### C. ConsultedServiceUpdateRequestSchema

**Allow partial updates:**

```typescript
export const ConsultedServiceUpdateRequestSchema =
  ConsultedServiceCreateRequestSchema.partial();

export type ConsultedServiceUpdateRequest = z.infer<
  typeof ConsultedServiceUpdateRequestSchema
>;
```

#### D. UpdateStageRequestSchema (New)

**For pipeline drag & drop:**

```typescript
export const UpdateStageRequestSchema = z
  .object({
    stage: z.enum([
      "NEW",
      "CONTACTING",
      "SCHEDULED",
      "ARRIVED",
      "LOST",
      "CONSULTING",
      "QUOTED",
      "DEPOSIT",
      "TREATING",
    ]),
    lostReason: z.string().trim().optional().nullable(), // Required if stage = LOST
    lostDate: z.coerce.date().optional().nullable(),
    lostAtStage: z.string().trim().optional().nullable(), // ‚≠ê Will be set automatically by backend
  })
  .refine(
    (data) => {
      // If stage = LOST, lostReason is required
      if (data.stage === "LOST" && !data.lostReason) {
        return false;
      }
      return true;
    },
    {
      message: "Vui l√≤ng nh·∫≠p l√Ω do th·∫•t b·∫°i",
      path: ["lostReason"],
    }
  );

export type UpdateStageRequest = z.infer<typeof UpdateStageRequestSchema>;
```

#### E. UpdateFollowUpRequestSchema (New)

**For follow-up scheduling:**

````typescript
export const UpdateFollowUpRequestSchema = z.object({
  followUpPriority: z.enum(["HIGH", "MEDIUM", "LOW"]).nullable(),
  nextFollowUpDate: z.coerce.date().nullable(),
});

export type UpdateFollowUpRequest = z.infer<typeof UpdateFollowUpRequestSchema>;
``` (keep nested structure):**

```typescript
export const ConsultedServiceResponseSchema = z.object({
  id: z.string(),
  // ... existing fields

  // ‚≠ê NEW fields
  source: z.string(),
  sourceNotes: z.string().nullable(),
  stage: z.string(), // 2-Phase Pipeline stages
  followUpPriority: z.string().nullable(),
  nextFollowUpDate: z.string().datetime().nullable(),
  lostReason: z.string().nullable(),
  lostDate: z.string().datetime().nullable(),
  lostAtStage: z.string().nullable(), // Pipeline stage when lost
  serviceConfirmDate: z.string().datetime().nullable(), // Ng√†y b·∫•m "Ch·ªët" - b·∫Øt ƒë·∫ßu ƒëi·ªÅu tr·ªã

  // ‚≠ê Nested relations (kh√¥ng flatten)
  saleOnline: z.object({
    id: z.string(),
    fullName: z.string()
  }).nullable(),
  customer: z.object({
    id: z.string(),
    fullName: z.string(),
    phone: z.string().nullable(),
  }),
  dentalService: z.object({
    id: z.string(),
    name: z.string()
  }),
  // ... other relations
});

export type ConsultedServiceResponse = z.infer<typeof ConsultedServiceResponseSchema>;lable(),
saleOnlineId: z.string().nullable(),
saleOnline: z.object({ id: z.string(), fullName: z.string() }).nullable(),
lostReason: z.string().nullable(),
lostDate: z.string().datetime().nullable(),
````

---

### 2. Repository Updates (`src/server/repos/consulted-service.repo.ts`)

#### A. Create Method

**Add source and stage:**

```typescript
async create(data: Prisma.ConsultedServiceCreateInput) {
  // ‚≠ê Get customer to determine initial stage
  const customer = await prisma.customer.findUnique({
    where: { id: data.customerId },
    select: { type: true },
  });

  // ‚≠ê Set stage based on customer type:
  // - LEAD: Start at NEW (need to contact and bring to clinic)
  // - CUSTOMER: Start at ARRIVED (already at clinic, ready for consultation)
  const initialStage = data.stage || (customer?.type === "LEAD" ? "NEW" : "ARRIVED");

  return prisma.consultedService.create({
    data: {
      ...data,
      source: data.source, // ‚≠ê Required
      stage: initialStage,
    },
    include: {
      customer: true,
      dentalService: true,
      consultingSale: true,
      consultingDoctor: true,
      treatingDoctor: true,
      saleOnline: true, // ‚≠ê NEW relation
    },
  });
}
```

#### B. List Method

**Add filters for source and stage:**

```typescript
async list(params: {
  clinicId?: string;
  customerId?: string;
  source?: string; // ‚≠ê NEW filter
  stage?: string; // ‚≠ê NEW filter
  saleOnlineId?: string; // ‚≠ê NEW filter
  dateFrom?: Date;
  dateTo?: Date;
  skip?: number;
  take?: number;
}) {
  const where: Prisma.ConsultedServiceWhereInput = {
    clinicId: params.clinicId,
    customerId: params.customerId,
    source: params.source, // ‚≠ê Filter by deal source
    stage: params.stage, // ‚≠ê Filter by pipeline stage
    saleOnlineId: params.saleOnlineId, // ‚≠ê Filter by telesale
    createdAt: {
      gte: params.dateFrom,
      lte: params.dateTo,
    },
  };

  return prisma.consultedService.findMany({
    where,
    include: {
      customer: true,
      dentalService: true,
      consultingSale: true,
      consultingDoctor: true,
      treatingDoctor: true,
      saleOnline: true, // ‚≠ê Include telesale
    },
    orderBy: { createdAt: "desc" },
    skip: params.skip,
    take: params.take,
  });
}
```

#### C. New Query: findDealsForFollowUp

**Get active deals needing follow-up:**

```typescript
async findDealsForFollowUp(params: {
  saleId?: string;
  date: Date;
  clinicId?: string;
}) {
  const startOfDay = new Date(params.date);
  startOfDay.setHours(0, 0, 0, 0);
  const endOfDay = new Date(params.date);
  endOfDay.setHours(23, 59, 59, 999);

  return prisma.consultedService.findMany({
    where: {
      stage: { notIn: ["LOST", "TREATING"] }, // ‚≠ê Active deals (bao g·ªìm DEPOSIT v√¨ c√≥ th·ªÉ h·ªßy)
      nextFollowUpDate: {
        gte: startOfDay,
        lte: endOfDay,
      },
      clinicId: params.clinicId,
      OR: params.saleId
        ? [
            { saleOnlineId: params.saleId },
            { consultingSaleId: params.saleId },
          ]
        : undefined,
    },
    include: {
      customer: { select: { id: true, fullName: true, phone: true } },
      dentalService: { select: { id: true, name: true } },
      saleOnline: { select: { id: true, fullName: true } },
      consultingSale: { select: { id: true, fullName: true } },
    },
    orderBy: [
      { followUpPriority: "desc" }, // HIGH first
      { nextFollowUpDate: "asc" },
    ],
  });
}
```

#### D. New Query: findByStage

**Group deals by stage for Kanban:**

```typescript
async findByStage(params: {
  clinicId?: string;
  saleId?: string;
  dateFrom?: Date;
  dateTo?: Date;
}) {
  const where: Prisma.ConsultedServiceWhereInput = {
    clinicId: params.clinicId,
    createdAt: {
      gte: params.dateFrom,
      lte: params.dateTo,
    },
    OR: params.saleId
      ? [
          { saleOnlineId: params.saleId },
          { consultingSaleId: params.saleId },
        ]
      : undefined,
  };

  return prisma.consultedService.findMany({
    where,
    include: {
      customer: { select: { id: true, fullName: true, phone: true } },
      dentalService: { select: { id: true, name: true } },
      saleOnline: { select: { id: true, fullName: true } },
      consultingSale: { select: { id: true, fullName: true } },
    },
    orderBy: [
      { stage: "asc" },
      { createdAt: "desc" },
    ],
  });
}
```

#### E. Update Method

**Handle stage transitions:**

```typescript
async update(id: string, data: Prisma.ConsultedServiceUpdateInput) {
  // If stage changes to LOST, capture current stage and set lostDate
  if (data.stage === "LOST") {
    // Get current stage before updating to LOST
    const current = await prisma.consultedService.findUnique({
      where: { id },
      select: { stage: true },
    });

    if (!data.lostDate) {
      data.lostDate = new Date();
    }
    if (!data.lostAtStage && current?.stage && current.stage !== "LOST") {
      data.lostAtStage = current.stage; // ‚≠ê Snapshot stage before lost
    }
  }

  // Note: serviceConfirmDate is set separately when user clicks "Ch·ªët" button
  // (not automatically when stage changes to TREATING)

  return prisma.consultedService.update({
    where: { id },
    data,
    include: {Request
      customer: true,
      dentalService: true,
      consultingSale: true,
      consultingDoctor: true,
      treatingDoctor: true,
      saleOnline: true,
    },
  });
}
```

---

### 3. Service Updates (`src/server/services/consulted-service.service.ts`)

#### A. Create Method

**Validate source and set default stage:**

```typescript
async create(currentUser: UserCore, body: unknown) {
  const parsed = ConsultedServiceCreateSchema.safeParse(body);
  if (!parsed.success) {
    throw new ServiceError("VALIDATION_ERROR", parsed.error.message, 400);
  }

  const data = parsed.data;

  // Validate clinic access
  if (currentUser.role !== "admin" && data.clinicId !== currentUser.clinicId) {
    throw new ServiceError("CLINIC_MISMATCH", "Kh√¥ng c√≥ quy·ªÅn t·∫°o deal cho chi nh√°nh n√†y", 403);
  }

  // ‚≠ê Ensure source is provided
  if (!data.source) {
    throw new ServiceError("VALIDATION_ERROR", "Ngu·ªìn deal l√† b·∫Øt bu·ªôc", 400);
  }

  // ‚≠ê Stage will be set by repo based on customer.type:
  // - If customer.type = LEAD ‚Üí stage = NEW (Lead Pipeline)
  // - If customer.type = CUSTOMER ‚Üí stage = ARRIVED (Opportunity Pipeline)
  // User can override by providing stage explicitly

  // Create deal
  const consultedService = await consultedServiceRepo.create({
    ...data,
    createdById: currentUser.employeeId,
  });

  return mapConsultedServiceToResponse(consultedService);
}
```

#### B. Update Method

**Handle stage transitions:**

```typescript
async update(currentUser: UserCore, id: string, body: unknown) {
  const parsed = ConsultedServiceUpdateRequestSchema.safeParse(body);
  if (!parsed.success) {
    throw new ServiceError("VALIDATION_ERROR", parsed.error.message, 400);
  }

  const data = parsed.data;

  // Get existing deal
  const existing = await consultedServiceRepo.findById(id);
  if (!existing) {
    throw new ServiceError("NOT_FOUND", "Kh√¥ng t√¨m th·∫•y deal", 404);
  }

  // Validate clinic access
  if (currentUser.role !== "admin" && existing.clinicId !== currentUser.clinicId) {
    throw new ServiceError("CLINIC_MISMATCH", "Kh√¥ng c√≥ quy·ªÅn c·∫≠p nh·∫≠t deal n√†y", 403);
  }

// ‚≠ê Handle stage transition to LOST
  if (data.stage === "LOST") {
    if (!data.lostReason) {
      throw new ServiceError("VALIDATION_ERROR", "Vui l√≤ng nh·∫≠p l√Ω do th·∫•t b·∫°i", 400);
    }
    data.lostDate = new Date();
  }

  // ‚≠ê Handle stage transition to TREATING (won deal - th√†nh c√¥ng cu·ªëi c√πng)
  if (data.stage === "TREATING") {
    data.wonDate = new Date();
  }

  // DEPOSIT kh√¥ng set wonDate v√¨ c√≥ th·ªÉ h·ªßy
}
```

#### C. New Method: updateStage

**For pipeline drag & drop:**

```typescript
async updateStage(currentUser: UserCore, id: string, body: unknown) {
  const parsed = UpdateStageRequestSchema.safeParse(body);
  if (!parsed.success) {
    throw new ServiceError("VALIDATION_ERROR", parsed.error.message, 400);
  }

  const data = parsed.data;

  // Get existing deal
  const existing = await consultedServiceRepo.findById(id);
  if (!existing) {
    throw new ServiceError("NOT_FOUND", "Kh√¥ng t√¨m th·∫•y deal", 404);
  }

  // Validate clinic access
  if (currentUser.role !== "admin" && existing.clinicId !== currentUser.clinicId) {
    throw new ServiceError("CLINIC_MISMATCH", "Kh√¥ng c√≥ quy·ªÅn c·∫≠p nh·∫≠t deal n√†y", 403);
  }

  // Update stage
  const updated = await consultedServiceRepo.update(id, {
    stage: data.stage,
    lostReason: data.lostReason,
    lostDate: data.lostDate || (data.stage === "LOST" ? new Date() : null),
    // lostAtStage will be set automatically by repo.update (snapshot current stage)
    // Note: serviceConfirmDate is set separately via "Ch·ªët" button action
    updatedById: currentUser.employeeId,
  });

  return mapConsultedServiceToResponse(updated);
}
```

#### D. New Method: updateFollowUp

**For follow-up scheduling:**

```typescript
async updateFollowUp(currentUser: UserCore, id: string, body: unknown) {
  const parsed = UpdateFollowUpRequestSchema.safeParse(body);
  if (!parsed.success) {
    throw new ServiceError("VALIDATION_ERROR", parsed.error.message, 400);
  }

  const data = parsed.data;

  // Get existing deal
  const existing = await consultedServiceRepo.findById(id);
  if (!existing) {
    throw new ServiceError("NOT_FOUND", "Kh√¥ng t√¨m th·∫•y deal", 404);
  }

  // Validate clinic access
  if (currentUser.role !== "admin" && existing.clinicId !== currentUser.clinicId) {
    throw new ServiceError("CLINIC_MISMATCH", "Kh√¥ng c√≥ quy·ªÅn c·∫≠p nh·∫≠t deal n√†y", 403);
  }

  // Update follow-up fields
  const updated = await consultedServiceRepo.update(id, {
    followUpPriority: data.followUpPriority,
    nextFollowUpDate: data.nextFollowUpDate,
    updatedById: currentUser.employeeId,
  });

  return mapConsultedServiceToResponse(updated);
}
```

---

### 4. Server Actions (`src/server/actions/consulted-service.actions.ts`)

**Add new actions:**

```typescript
"use server";

import { getSessionUser } from "@/server/utils/sessionCache";
import { consultedServiceService } from "@/server/services/consulted-service.service";

// ‚≠ê NEW: Update stage (for Kanban drag & drop)
export async function updateConsultedServiceStageAction(
  id: string,
  data: { stage: string; lostReason?: string }
) {
  const user = await getSessionUser();
  return await consultedServiceService.updateStage(user, id, data);
}

// ‚≠ê NEW: Update follow-up (for follow-up scheduling)
export async function updateConsultedServiceFollowUpAction(
  id: string,
  data: { followUpPriority?: string | null; nextFollowUpDate?: Date | null }
) {
  const user = await getSessionUser();
  return await consultedServiceService.updateFollowUp(user, id, data);
}

// ‚≠ê EXISTING: Update with new fields
export async function updateConsultedServiceAction(id: string, data: unknown) {
  const user = await getSessionUser();
  return await consultedServiceService.update(user, id, data);
}
```

---

### 5. API Routes

#### A. Update List Route (`src/app/api/v1/consulted-services/route.ts`)

**Add filters for source, stage, saleOnlineId:**

```typescript
/**
 * GET /api/v1/consulted-services - List consulted services with filters
 * Query params: clinicId, customerId, source, stage, saleOnlineId, dateFrom, dateTo, skip, take
 * Used by: useConsultedServices hook
 * Cache: No cache (transactional data)
 */
export async function GET(req: Request) {
  try {
    const user = await getSessionUser();
    const { searchParams } = new URL(req.url);

    const params = {
      clinicId: searchParams.get("clinicId") || undefined,
      customerId: searchParams.get("customerId") || undefined,
      source: searchParams.get("source") || undefined, // ‚≠ê NEW
      stage: searchParams.get("stage") || undefined, // ‚≠ê NEW
      saleOnlineId: searchParams.get("saleOnlineId") || undefined, // ‚≠ê NEW
      dateFrom: searchParams.get("dateFrom")
        ? new Date(searchParams.get("dateFrom")!)
        : undefined,
      dateTo: searchParams.get("dateTo")
        ? new Date(searchParams.get("dateTo")!)
        : undefined,
      skip: searchParams.get("skip")
        ? parseInt(searchParams.get("skip")!)
        : undefined,
      take: searchParams.get("take")
        ? parseInt(searchParams.get("take")!)
        : undefined,
    };

    const result = await consultedServiceService.list(user, params);
    return NextResponse.json({ success: true, data: result });
  } catch (e: unknown) {
    if (e instanceof ServiceError) {
      return NextResponse.json(
        { error: e.message, code: e.code },
        { status: e.httpStatus }
/**
 * GET /api/v1/consulted-services/follow-ups - Get active deals needing follow-up
 * Query params: date, saleId, clinicId
 * Used by: useDealsForFollowUp hook
 * Cache: No cache (transactional data - changes frequently)
 */
export async function GET(req: Request) {
  try {
    const user = await getSessionUser();
    const { searchParams } = new URL(req.url);

    const date = searchParams.get("date")
      ? new Date(searchParams.get("date")!)
      : new Date();
    const saleId = searchParams.get("saleId") || undefined;
    const clinicId = searchParams.get("clinicId") || user.clinicId;

    const result = await consultedServiceRepo.findDealsForFollowUp({
      date,
      saleId,
      clinicId,
    });

    return NextResponse.json({ success: true, data: result });
  } catch (e: unknown) {
    if (e instanceof ServiceError) {
      return NextResponse.json(
        { error: e.message, code: e.code },
        { status: e.httpStatus }
      );
    }
    return NextResponse.json(
      { error: COMMON_MESSAGES.SERVER_ERROR },
      { status: 500 }

    const date = searchParams.get("date")
      ? new Date(searchParams.get("date")!)
      : new Date();
    const saleId = searchParams.get("saleId") || undefined;
    const clinicId = searchParams.get("clinicId") || user.clinicId;

    const result = await consultedServiceRepo.findDealsForFollowUp({
      date,
      saleId,
      clinicId,
    });

    return NextResponse.json({ success: true, data: result });
  } catch (error) {
    return handleApiError(error);
  }
}
```

#### C. New Route: Get Deals by Stage

**`src/app/api/v1/consulted-services/by-stage/route.ts`:**

```typescript
export async function GET(req: Request) {
  try {
    const user = await getSessionUser();
    const { searchParams } = new URL(req.url);

    const params = {
      clinicId: searchParams.get("clinicId") || user.clinicId,
      saleId: searchParams.get("saleId") || undefined,
      dateFrom: searchParams.get("dateFrom")
        ? new Date(searchParams.get("dateFrom")!)
        : undefined,
      dateTo: searchParams.get("dateTo")
        ? new Date(searchParams.get("dateTo")!)
        : undefined,
    };

    const result = await consultedServiceRepo.findByStage(params);

    // Group by stage
    const grouped = result.reduce((acc, deal) => {
      if (!acc[deal.stage]) {
        acc[deal.stage] = [];
      }
      acc[deal.stage].push(deal);
      return acc;
    }, {} as Record<string, typeof result>);

    return NextResponse.json({ success: true, data: grouped });
  } catch (error) {
    return handleApiError(error);
  }
}
```

---

## üé® FRONTEND CHANGES

### 1. ConsultedServiceFormModal Updates

**File:** `src/features/consulted-services/components/ConsultedServiceFormModal.tsx`

#### A. Add New Fields (After existing fields)

**Row: Deal Source (12 cols) | Source Notes (12 cols)**

```tsx
<Row gutter={12}>
  <Col xs={24} lg={12}>
    <Form.Item
      label="Ngu·ªìn deal"
      name="source"
      rules={[{ required: true, message: "Vui l√≤ng ch·ªçn ngu·ªìn deal" }]}
      tooltip="Ngu·ªìn c·ªßa deal n√†y (campaign c·ª• th·ªÉ)"
    >
      <Select
        placeholder="Ch·ªçn ngu·ªìn deal"
        options={DEAL_SOURCE_OPTIONS}
        showSearch
        filterOption={(input, option) =>
          (option?.label ?? "").toLowerCase().includes(input.toLowerCase())
        }
      />
    </Form.Item>
  </Col>
  <Col xs={24} lg={12}>
    <Form.Item label="Ghi ch√∫ ngu·ªìn" name="sourceNotes">
      <Input.TextArea
        placeholder="VD: Facebook Ads - Campaign Th√°ng 12"
        rows={1}
      />
    </Form.Item>
  </Col>
</Row>
```

**Row: Pipeline Stage (8 cols) | Follow-up Priority (8 cols) | Next Follow-up Date (8 cols)**

```tsx
<Row gutter={12}>
  <Col xs={24} lg={8}>
    <Form.Item
      label="Tr·∫°ng th√°i"
      name="stage"
      rules={[{ required: true, message: "Vui l√≤ng ch·ªçn tr·∫°ng th√°i" }]}
    >
      <Select placeholder="Ch·ªçn tr·∫°ng th√°i" options={PIPELINE_STAGE_OPTIONS} />
    </Form.Item>
  </Col>
  <Col xs={24} lg={8}>
    <Form.Item label="ƒê·ªô ∆∞u ti√™n follow-up" name="followUpPriority">
      <Select
        placeholder="Ch·ªçn ƒë·ªô ∆∞u ti√™n"
        options={[
          { label: "Cao", value: "HIGH" },
          { label: "Trung b√¨nh", value: "MEDIUM" },
          { label: "Th·∫•p", value: "LOW" },
        ]}
        allowClear
      />
    </Form.Item>
  </Col>
  <Col xs={24} lg={8}>
    <Form.Item label="Ng√†y follow-up ti·∫øp theo" name="nextFollowUpDate">
      <DatePicker
        style={{ width: "100%" }}
        format="DD/MM/YYYY"
        placeholder="Ch·ªçn ng√†y"
      />
    </Form.Item>
  </Col>
</Row>
```

**Row: Sale Online (12 cols) | Lost Reason (12 cols) - Conditional**

```tsx
<Row gutter={12}>
  <Col xs={24} lg={12}>
    <Form.Item label="Sale Online (Telesale)" name="saleOnlineId">
      <Select
        placeholder="Ch·ªçn sale online"
        options={saleOnlineOptions}
        showSearch
        filterOption={(input, option) =>
          (option?.label ?? "").toLowerCase().includes(input.toLowerCase())
        }
        allowClear
      />
    </Form.Item>
  </Col>
  <Col xs={24} lg={12}>
    <Form.Item noStyle shouldUpdate={(prev, curr) => prev.stage !== curr.stage}>
      {({ getFieldValue }) => {
        const stage = getFieldValue("stage");
        return stage === "LOST" ? (
          <Form.Item
            label="L√Ω do th·∫•t b·∫°i"
            name="lostReason"
            rules={[{ required: true, message: "Vui l√≤ng nh·∫≠p l√Ω do" }]}
          >
            <Input.TextArea placeholder="Nh·∫≠p l√Ω do th·∫•t b·∫°i" rows={1} />
          </Form.Item>
        ) : null;
      }}
    </Form.Item>
  </Col>
</Row>
```

#### B. Constants File

**`src/features/consulted-services/constants.ts`:**

```typescript
import { CUSTOMER_SOURCES } from "@/features/customers/constants";

// ‚≠ê Query Keys (GUIDELINES requirement)
export const CONSULTED_SERVICE_QUERY_KEYS = {
  list: (params?: any) => ["consultedServices", params] as const,
  byId: (id: string) => ["consultedService", id] as const,
  followUps: (params?: any) =>
    ["consultedServices", "followUps", params] as const,
  byStage: (params?: any) => ["consultedServices", "byStage", params] as const,
} as const;

// ‚≠ê 2-Phase Real-World Pipeline
// Phase 1: Lead Pipeline (Sale Online) - M·ª•c ti√™u: K√©o kh√°ch ƒë·∫øn ph√≤ng kh√°m
// Phase 2: Opportunity Pipeline (Sale Offline/Doctor) - M·ª•c ti√™u: Ch·ªët ti·ªÅn v√† ƒêi·ªÅu tr·ªã

export const PIPELINE_STAGE_OPTIONS = [
  // === PHASE 1: LEAD PIPELINE (Sale Online) ===
  { label: "M·ªõi", value: "NEW", color: "blue", phase: "lead" },
  { label: "ƒêang li√™n h·ªá", value: "CONTACTING", color: "cyan", phase: "lead" },
  {
    label: "ƒê√£ ƒë·∫∑t l·ªãch",
    value: "SCHEDULED",
    color: "geekblue",
    phase: "lead",
  },
  { label: "ƒê√£ ƒë·∫øn", value: "ARRIVED", color: "purple", phase: "lead" }, // KPI Sale Online

  // === PHASE 2: OPPORTUNITY PIPELINE (Sale Offline/Doctor) ===
  {
    label: "ƒêang t∆∞ v·∫•n",
    value: "CONSULTING",
    color: "orange",
    phase: "opportunity",
  },
  { label: "ƒê√£ b√°o gi√°", value: "QUOTED", color: "gold", phase: "opportunity" },
  { label: "ƒê√£ c·ªçc", value: "DEPOSIT", color: "green", phase: "opportunity" }, // WIN - End state
  {
    label: "ƒêang ƒëi·ªÅu tr·ªã",
    value: "TREATING",
    color: "lime",
    phase: "opportunity",
  }, // Post-WIN

  // === END STATE (c√≥ th·ªÉ x·∫£y ra ·ªü b·∫•t k·ª≥ phase n√†o) ===
  { label: "Th·∫•t b·∫°i", value: "LOST", color: "red", phase: "end" },
];

// ‚≠ê Reuse CUSTOMER_SOURCES from Customer feature
// Deal source same as customer source (gi·ªØ consistency)
export const DEAL_SOURCE_OPTIONS = CUSTOMER_SOURCES.map((source) => ({
  label: source.label,
  value: source.value,
}));

export const FOLLOW_UP_PRIORITY_OPTIONS = [
  { label: "Cao", value: "HIGH", color: "red" },
  { label: "Trung b√¨nh", value: "MEDIUM", color: "orange" },
  { label: "Th·∫•p", value: "LOW", color: "blue" },
];

// ‚≠ê Messages (GUIDELINES requirement)
export const CONSULTED_SERVICE_MESSAGES = {
  CREATE_SUCCESS: "T·∫°o deal th√†nh c√¥ng",
  UPDATE_SUCCESS: "C·∫≠p nh·∫≠t deal th√†nh c√¥ng",
  DELETE_SUCCESS: "X√≥a deal th√†nh c√¥ng",
  UPDATE_STAGE_SUCCESS: "C·∫≠p nh·∫≠t tr·∫°ng th√°i th√†nh c√¥ng",
  UPDATE_FOLLOW_UP_SUCCESS: "C·∫≠p nh·∫≠t l·ªãch follow-up th√†nh c√¥ng",
} as const;
```

#### C. Form Initial Values

**For create mode:**

```typescript
const initialValues = {
  // ... existing fields
  source: undefined, // User must select
  sourceNotes: "",
  stage: undefined, // ‚≠ê Will be set by backend based on customer.type (LEAD‚ÜíNEW, CUSTOMER‚ÜíARRIVED)
  followUpPriority: undefined,
  nextFollowUpDate: undefined,
  saleOnlineId: undefined,
  lostReason: undefined,
};
```

**For edit mode:**

```typescript
const initialValues = {
  // ... existing fields
  source: data.source,
  sourceNotes: data.sourceNotes,
  stage: data.stage,
  followUpPriority: data.followUpPriority,
  nextFollowUpDate: data.nextFollowUpDate
    ? dayjs(data.nextFollowUpDate)
    : undefined,
  saleOnlineId: data.saleOnlineId,
  lostReason: data.lostReason,
};
```

---

### 2. ConsultedServiceTable Updates

**File:** `src/features/consulted-services/components/ConsultedServiceTable.tsx`

#### A. Add New Columns

**After "D·ªãch v·ª•" column:**

```tsx
{
  title: "Ngu·ªìn deal",
  key: "source",
  width: 120,
  render: (_, record) => record.source || "‚Äî",
}
```

**After "Tr·∫°ng th√°i" column:**

```tsx
{
  title: "Pipeline",
  key: "stage",
  width: 120,
  render: (_, record) => {
    const stageConfig = PIPELINE_STAGE_OPTIONS.find(s => s.value === record.stage);
    return (
      <Tag color={stageConfig?.color || "default"}>
        {stageConfig?.label || record.stage}
      </Tag>
    );
  },
}
```

**New column: Follow-up**

```tsx
{
  title: "Follow-up",
  key: "followUp",
  width: 150,
  render: (_, record) => {
    // Only show for active deals (not yet won or lost)
    if (["LOST", "TREATING"].includes(record.stage)) {
      return "‚Äî";
    }
    // DEPOSIT v·∫´n hi·ªán follow-up v√¨ c√≥ th·ªÉ h·ªßy

    if (!record.nextFollowUpDate) {
      return <Text type="secondary">Ch∆∞a ƒë·∫∑t l·ªãch</Text>;
    }

    const date = dayjs(record.nextFollowUpDate);
    const isOverdue = date.isBefore(dayjs(), "day");
    const isToday = date.isSame(dayjs(), "day");

    return (
      <Space direction="vertical" size={0}>
        <Text type={isOverdue ? "danger" : isToday ? "warning" : "secondary"}>
          {date.format("DD/MM/YYYY")}
        </Text>
        {record.followUpPriority && (
          <Tag
            color={
              record.followUpPriority === "HIGH"
                ? "red"
                : record.followUpPriority === "MEDIUM"
                ? "orange"
                : "blue"
            }
            style={{ fontSize: "10px" }}
          >
            {record.followUpPriority}
          </Tag>
        )}
      </Space>
    );
  },
}
```

**After "T∆∞ v·∫•n" column:**

```tsx
{
  title: "Sale Online",
  key: "saleOnline",
  width: 120,
  render: (_, record) => record.saleOnline?.fullName || "‚Äî",
}
```

#### B. Update Filters

**Add stage filter:**

```tsx
<Form.Item label="Tr·∫°ng th√°i" name="stage">
  <Select
    placeholder="T·∫•t c·∫£ tr·∫°ng th√°i"
    options={PIPELINE_STAGE_OPTIONS}
    allowClear
  />
</Form.Item>
```

**Add source filter:**

```tsx
<Form.Item label="Ngu·ªìn deal" name="source">
  <Select placeholder="T·∫•t c·∫£ ngu·ªìn" options={DEAL_SOURCE_OPTIONS} allowClear />
</Form.Item>
```

---

### 3. ConsultedServiceDetailView Updates

**File:** `src/features/consulted-services/views/ConsultedServiceDetailView.tsx`

#### A. Add Deal Source Section

**After customer info:**

```tsx
<Descriptions column={2} bordered>
  <Descriptions.Item label="Ngu·ªìn deal">{data.source || "‚Äî"}</Descriptions.Item>
  <Descriptions.Item label="Ghi ch√∫ ngu·ªìn">
    {data.sourceNotes || "‚Äî"}
  </Descriptions.Item>
  <Descriptions.Item label="Ngu·ªìn kh√°ch h√†ng" span={2}>
    <Text type="secondary">
      {data.customer.source || "‚Äî"} (ngu·ªìn g·ªëc ban ƒë·∫ßu)
    </Text>
  </Descriptions.Item>
</Descriptions>
```

#### B. Add Pipeline Stage Badge

**In header:**

```tsx
<Space>
  <Title level={3}>{data.dentalService.name}</Title>
  <Tag
    color={PIPELINE_STAGE_OPTIONS.find((s) => s.value === data.stage)?.color}
  >
    {PIPELINE_STAGE_OPTIONS.find((s) => s.value === data.stage)?.label ||
      data.stage}
  </Tag>
  {data.followUpPriority && (
    <Tag color={data.followUpPriority === "HIGH" ? "red" : "orange"}>
      Priority: {data.followUpPriority}
    </Tag>
  )}
</Space>
```

#### C. Add Follow-up Section

**New section:**

```tsx
<Card title="Follow-up" style={{ marginTop: 16 }}>
  <Descriptions column={2} bordered>
    <Descriptions.Item label="Ng√†y follow-up ti·∫øp theo">
      {data.nextFollowUpDate ? (
        <Space>
          {dayjs(data.nextFollowUpDate).format("DD/MM/YYYY HH:mm")}
          {dayjs(data.nextFollowUpDate).isBefore(dayjs(), "day") && (
            <Tag color="red">Qu√° h·∫°n</Tag>
          )}
          {dayjs(data.nextFollowUpDate).isSame(dayjs(), "day") && (
            <Tag color="orange">H√¥m nay</Tag>
          )}
        </Space>
      ) : (
        "Ch∆∞a ƒë·∫∑t l·ªãch"
      )}
    </Descriptions.Item>
    <Descriptions.Item label="ƒê·ªô ∆∞u ti√™n">
      {data.followUpPriority ? (
        <Tag
          color={
            data.followUpPriority === "HIGH"
              ? "red"
              : data.followUpPriority === "MEDIUM"
              ? "orange"
              : "blue"
          }
        >
          {data.followUpPriority}
        </Tag>
      ) : (
        "‚Äî"
      )}
    </Descriptions.Item>
    <Descriptions.Item label="Sale Online">
      {data.saleOnline?.fullName || "‚Äî"}
    </Descriptions.Item>
    <Descriptions.Item label="Sale Offline">
      {data.consultingSale?.fullName || "‚Äî"}
    </Descriptions.Item>
  </Descriptions>

  <Button
    type="primary"
    icon={<CalendarOutlined />}
    style={{ marginTop: 16 }}
    onClick={() => setShowFollowUpModal(true)}
  >
    C·∫≠p nh·∫≠t l·ªãch follow-up
  </Button>
</Card>
```

#### D. Add Failed/Won Status Sections

```tsx
{
  /* Lost deal info */
}
{
  data.stage === "LOST" && (
    <Card title="Th√¥ng tin th·∫•t b·∫°i" style={{ marginTop: 16 }}>
      <Descriptions column={1} bordered>
        <Descriptions.Item label="Giai ƒëo·∫°n khi th·∫•t b·∫°i">
          {data.lostAtStage ? (
            <Tag
              color={
                PIPELINE_STAGE_OPTIONS.find((s) => s.value === data.lostAtStage)
                  ?.color
              }
            >
              {
                PIPELINE_STAGE_OPTIONS.find((s) => s.value === data.lostAtStage)
                  ?.label
              }
            </Tag>
          ) : (
            "‚Äî"
          )}
        </Descriptions.Item>
        <Descriptions.Item label="L√Ω do">
          {data.lostReason || "‚Äî"}
        </Descriptions.Item>
        <Descriptions.Item label="Ng√†y th·∫•t b·∫°i">
          {data.lostDate ? dayjs(data.lostDate).format("DD/MM/YYYY") : "‚Äî"}
        </Descriptions.Item>
      </Descriptions>
    </Card>
  );
}

{
  /* Won deal info */
}
{
  ["DEPOSIT", "TREATING"].includes(data.stage) && (
    <Card title="Th√¥ng tin th√†nh c√¥ng" style={{ marginTop: 16 }}>
      <Descriptions column={1} bordered>
        <Descriptions.Item label="Tr·∫°ng th√°i">
          <Tag color="green">
            {data.stage === "DEPOSIT" ? "ƒê√£ c·ªçc" : "ƒêang ƒëi·ªÅu tr·ªã"}
          </Tag>
        </Descriptions.Item>
        <Descriptions.Item label="Ng√†y ch·ªët ƒëi·ªÅu tr·ªã">
          {data.serviceConfirmDate ? (
            <>
              {dayjs(data.serviceConfirmDate).format("DD/MM/YYYY")}
              <Text type="secondary" style={{ marginLeft: 8 }}>
                (Ng√†y b·∫•m "Ch·ªët")
              </Text>
            </>
          ) : (
            "‚Äî"
          )}
        </Descriptions.Item>
      </Descriptions>
    </Card>
  );
}
```

---

### 4. New Components

#### A. UpdateFollowUpModal

**`src/features/consulted-services/components/UpdateFollowUpModal.tsx`:**

```tsx
interface UpdateFollowUpModalProps {
  open: boolean;
  consultedServiceId: string;
  initialData?: {
    followUpPriority?: string | null;
    nextFollowUpDate?: string | null;
  };
  onCancel: () => void;
  onSuccess: () => void;
}

export function UpdateFollowUpModal({
  open,
  consultedServiceId,
  initialData,
  onCancel,
  onSuccess,
}: UpdateFollowUpModalProps) {
  const [form] = Form.useForm();
  const mutation = useUpdateFollowUp(consultedServiceId);

  const handleSubmit = async (values: any) => {
    await mutation.mutateAsync({
      followUpPriority: values.followUpPriority,
      nextFollowUpDate: values.nextFollowUpDate?.toDate(),
    });
    onSuccess();
  };

  return (
    <Modal
      open={open}
      title="C·∫≠p nh·∫≠t l·ªãch follow-up"
      onCancel={onCancel}
      onOk={() => form.submit()}
      confirmLoading={mutation.isPending}
    >
      <Form
        form={form}
        layout="vertical"
        onFinish={handleSubmit}
        initialValues={{
          followUpPriority: initialData?.followUpPriority,
          nextFollowUpDate: initialData?.nextFollowUpDate
            ? dayjs(initialData.nextFollowUpDate)
            : undefined,
        }}
      >
        <Form.Item label="ƒê·ªô ∆∞u ti√™n" name="followUpPriority">
          <Select
            placeholder="Ch·ªçn ƒë·ªô ∆∞u ti√™n"
            options={FOLLOW_UP_PRIORITY_OPTIONS}
            allowClear
          />
        </Form.Item>
        <Form.Item label="Ng√†y follow-up ti·∫øp theo" name="nextFollowUpDate">
          <DatePicker
            style={{ width: "100%" }}
            format="DD/MM/YYYY HH:mm"
            showTime
            placeholder="Ch·ªçn ng√†y gi·ªù"
          />
        </Form.Item>
      </Form>
    </Modal>
  );
}
```

#### B. StageUpdateModal

**`src/features/consulted-services/components/StageUpdateModal.tsx`:**

```tsx
interface StageUpdateModalProps {
  open: boolean;
  consultedServiceId: string;
  currentStage: string;
  onCancel: () => void;
  onSuccess: () => void;
}

export function StageUpdateModal({
  open,
  consultedServiceId,
  currentStage,
  onCancel,
  onSuccess,
}: StageUpdateModalProps) {
  const [form] = Form.useForm();
  const mutation = useUpdateStage(consultedServiceId);

  const handleSubmit = async (values: any) => {
    await mutation.mutateAsync({
      stage: values.stage,
      lostReason: values.lostReason,
    });
    onSuccess();
  };

  return (
    <Modal
      open={open}
      title="C·∫≠p nh·∫≠t tr·∫°ng th√°i deal"
      onCancel={onCancel}
      onOk={() => form.submit()}
      confirmLoading={mutation.isPending}
    >
      <Form
        form={form}
        layout="vertical"
        onFinish={handleSubmit}
        initialValues={{ stage: currentStage }}
      >
        <Form.Item
          label="Tr·∫°ng th√°i"
          name="stage"
          rules={[{ required: true, message: "Vui l√≤ng ch·ªçn tr·∫°ng th√°i" }]}
        >
          <Select
            placeholder="Ch·ªçn tr·∫°ng th√°i"
            options={PIPELINE_STAGE_OPTIONS}
          />
        </Form.Item>

        <Form.Item
          noStyle
          shouldUpdate={(prev, curr) => prev.stage !== curr.stage}
        >
          {({ getFieldValue }) => {
            const stage = getFieldValue("stage");
            return stage === "LOST" ? (
              <Form.Item
                label="L√Ω do th·∫•t b·∫°i"
                name="lostReason"
                rules={[{ required: true, message: "Vui l√≤ng nh·∫≠p l√Ω do" }]}
              >
                <Input.TextArea placeholder="Nh·∫≠p l√Ω do th·∫•t b·∫°i" rows={3} />
              </Form.Item>
            ) : null;
          }}
        </Form.Item>
      </Form>
    </Modal>
  );
}
```

---

### 5. React Query Hooks

#### A. useUpdateStage

**`src/features/consulted-services/hooks/useUpdateStage.ts`:**

```typescript
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { updateConsultedServiceStageAction } from "@/server/actions/consulted-service.actions";
import { useNotify } from "@/shared/hooks/useNotify";
import { CONSULTED_SERVICE_QUERY_KEYS, CONSULTED_SERVICE_MESSAGES } from "../constants";
import { COMMON_MESSAGES } from "@/shared/constants";

export function useUpdateStage(consultedServiceId: string) {
  const queryClient = useQueryClient();
  const notify = useNotify(); // ‚≠ê GUIDELINES: ALWAYS use useNotify()

  return useMutation({
    mutationFn: async (data: { stage: string; lostReason?: string }) => {
      return await updateConsultedServiceStageAction(consultedServiceId, data);
    },
    onSuccess: () => {
      notify.success(CONSULTED_SERVICE_MESSAGES.UPDATE_STAGE_SUCCESS);
      queryClient.invalidateQueries({ queryKey: CONSULTED_SERVICE_QUERY_KEYS.list() });
      queryClient.invalidateQueries({ queryKey: CONSULTED_SERVICE_QUERY_KEYS.byId(consultedServiceId) });
    },
    onError: (error) => {
      notify.error(error, { fallback: COMMON_MESSAGES.UNKNOWN_ERROR }

export function useUpdateStage(consultedServiceId: string) {
  const queryClient = useQueryClient();
  const notify = useNotify();

  return useMutation({
    mutationFn: async (data: { stage: string; lostReason?: string }) => {
      return await updateConsultedServiceStageAction(consultedServiceId, data);
    },
    onSuccess: () => {
      message.success("C·∫≠p nh·∫≠t tr·∫°ng th√°i th√†nh c√¥ng");
      queryClient.invalidateQueries({ queryKey: ["consultedServices"] });
      queuseNotify } from "@/shared/hooks/useNotify";
import { CONSULTED_SERVICE_QUERY_KEYS, CONSULTED_SERVICE_MESSAGES } from "../constants";
import { COMMON_MESSAGES } from "@/shared/constants";

export function useUpdateFollowUp(consultedServiceId: string) {
  const queryClient = useQueryClient();
  const notify = useNotify(); // ‚≠ê GUIDELINES: ALWAYS use useNotify()

  return useMutation({
    mutationFn: async (data: {
      followUpPriority?: string | null;
      nextFollowUpDate?: Date | null;
    }) => {
      return await updateConsultedServiceFollowUpAction(
        consultedServiceId,
        data
      );
    },
    onSuccess: () => {
      notify.success(CONSULTED_SERVICE_MESSAGES.UPDATE_FOLLOW_UP_SUCCESS);
      queryClient.invalidateQueries({ queryKey: CONSULTED_SERVICE_QUERY_KEYS.list() });
      queryClient.invalidateQueries({ queryKey: CONSULTED_SERVICE_QUERY_KEYS.byId(consultedServiceId) });
      queryClient.invalidateQueries({ queryKey: CONSULTED_SERVICE_QUERY_KEYS.followUps() });
    },
    onError: (error) => {
      notify.error(error, { fallback: COMMON_MESSAGES.UNKNOWN_ERROR }
    mutationFn: async (data: {
      followUpPriority?: string | null;
      nextFollowUpDate?: Date | null;
    }) => {
      return await updateConsultedServiceFollowUpAction(
        consultedServiceId,
        data
      );
    },
    onSuccess: () => {
import { CONSULTED_SERVICE_QUERY_KEYS } from "../constants";

export function useDealsForFollowUp(params: {
  date: Date;
  saleId?: string;
  clinicId?: string;
}) {
  return useQuery({
    queryKey: CONSULTED_SERVICE_QUERY_KEYS.followUps(params),
    queryFn: () => getDealsForFollowUpApi(params),
    staleTime: 60 * 1000, // 1 minute (transactional data)
    gcTime: 5 * 60 * 1000, // 5 minutes
    refetchOnWindowFocus: true
  });
}
```

#### C. useDealsForFollowUp

**`src/features/consulted-services/hooks/useDealsForFollowUp.ts`:**

```typescript
import { useQuery } from "@tanstack/react-query";
import { getDealsForFollowUpApi } from "../api";

export function useDealsForFollowUp(params: {
  date: Date;
  saleId?: string;
  clinicId?: string;
}) {
  return useQuery({
    queryKey: ["consultedServices", "followUps", params],
    queryFn: () => getDealsForFollowUpApi(params),
    enabled: !!params.date,
  });
}
```

---

### 5. Follow-up Dashboard (New Feature)

**Purpose:** M√†n h√¨nh ch√≠nh cho sales team xem danh s√°ch deals c·∫ßn follow-up h√¥m nay/ng√†y ƒë∆∞·ª£c ch·ªçn.

**Use Case:** Sales m·ªü app m·ªói s√°ng ‚Üí th·∫•y ngay danh s√°ch kh√°ch c·∫ßn g·ªçi ‚Üí click ƒë·ªÉ call tr·ª±c ti·∫øp.

---

#### A. FollowUpDashboard Component

**File:** `src/features/follow-ups/views/FollowUpDashboardView.tsx`

**Features:**

- Filter by date (default: h√¥m nay)
- Filter by sale (manager xem t·∫•t c·∫£, sales ch·ªâ xem c·ªßa m√¨nh)
- Display deals sorted by priority (HIGH ‚Üí MEDIUM ‚Üí LOW)
- Quick action: Click to call customer (tel: link)
- Badge indicators: Overdue (red), Today (orange), Upcoming (default)

**Implementation:**

```tsx
"use client";

import { useState } from "react";
import {
  Card,
  DatePicker,
  Select,
  List,
  Space,
  Tag,
  Button,
  Typography,
  Empty,
  Spin,
  Statistic,
  Row,
  Col,
} from "antd";
import {
  PhoneOutlined,
  CalendarOutlined,
  UserOutlined,
} from "@ant-design/icons";
import dayjs from "dayjs";
import { useAuth } from "@/features/auth/hooks/useAuth";
import { useDealsForFollowUp } from "@/features/consulted-services/hooks/useDealsForFollowUp";
import { useEmployees } from "@/features/employees/hooks/useEmployees";
import {
  FOLLOW_UP_PRIORITY_OPTIONS,
  PIPELINE_STAGE_OPTIONS,
} from "@/features/consulted-services/constants";

const { Text, Title } = Typography;

export function FollowUpDashboardView() {
  const { user } = useAuth();
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [selectedSale, setSelectedSale] = useState<string | undefined>(
    user.role === "employee" ? user.employeeId : undefined
  );

  // ‚≠ê Fetch deals c·∫ßn follow-up
  const { data: deals, isLoading } = useDealsForFollowUp({
    date: selectedDate,
    saleId: selectedSale,
    clinicId: user.clinicId,
  });

  // ‚≠ê Fetch danh s√°ch sales (cho manager)
  const { data: employees } = useEmployees({
    clinicId: user.clinicId,
    role: "sale",
  });

  const salesOptions = employees?.map((emp) => ({
    label: emp.fullName,
    value: emp.id,
  }));

  // ‚≠ê Statistics
  const totalDeals = deals?.length || 0;
  const highPriorityCount =
    deals?.filter((d) => d.followUpPriority === "HIGH").length || 0;
  const overdueCount =
    deals?.filter((d) => dayjs(d.nextFollowUpDate).isBefore(dayjs(), "day"))
      .length || 0;

  return (
    <div style={{ padding: "24px" }}>
      {/* Header */}
      <Title level={2}>üìû Follow-up Dashboard</Title>
      <Text type="secondary">Danh s√°ch deals c·∫ßn follow-up h√¥m nay</Text>

      {/* Filters */}
      <Card style={{ marginTop: 16, marginBottom: 16 }}>
        <Space size="large" wrap>
          <div>
            <Text strong>Ng√†y:</Text>
            <br />
            <DatePicker
              value={dayjs(selectedDate)}
              onChange={(date) => setSelectedDate(date?.toDate() || new Date())}
              format="DD/MM/YYYY"
              style={{ width: 200 }}
            />
          </div>

          {/* Manager c√≥ th·ªÉ ch·ªçn sale */}
          {user.role !== "employee" && (
            <div>
              <Text strong>Sale:</Text>
              <br />
              <Select
                value={selectedSale}
                onChange={setSelectedSale}
                options={[
                  { label: "T·∫•t c·∫£ sales", value: undefined },
                  ...(salesOptions || []),
                ]}
                style={{ width: 200 }}
                allowClear
              />
            </div>
          )}
        </Space>
      </Card>

      {/* Statistics */}
      <Row gutter={16} style={{ marginBottom: 16 }}>
        <Col span={8}>
          <Card>
            <Statistic
              title="T·ªïng deals"
              value={totalDeals}
              prefix={<CalendarOutlined />}
            />
          </Card>
        </Col>
        <Col span={8}>
          <Card>
            <Statistic
              title="Priority cao"
              value={highPriorityCount}
              valueStyle={{ color: "#cf1322" }}
              prefix={<UserOutlined />}
            />
          </Card>
        </Col>
        <Col span={8}>
          <Card>
            <Statistic
              title="Qu√° h·∫°n"
              value={overdueCount}
              valueStyle={{ color: overdueCount > 0 ? "#cf1322" : undefined }}
            />
          </Card>
        </Col>
      </Row>

      {/* Deals List */}
      <Card>
        {isLoading ? (
          <div style={{ textAlign: "center", padding: "40px" }}>
            <Spin size="large" />
          </div>
        ) : deals && deals.length > 0 ? (
          <List
            dataSource={deals}
            renderItem={(deal) => {
              const followUpDate = dayjs(deal.nextFollowUpDate);
              const isOverdue = followUpDate.isBefore(dayjs(), "day");
              const isToday = followUpDate.isSame(dayjs(), "day");

              const priorityConfig = FOLLOW_UP_PRIORITY_OPTIONS.find(
                (p) => p.value === deal.followUpPriority
              );
              const stageConfig = PIPELINE_STAGE_OPTIONS.find(
                (s) => s.value === deal.stage
              );

              return (
                <List.Item
                  key={deal.id}
                  actions={[
                    <Button
                      type="primary"
                      icon={<PhoneOutlined />}
                      href={`tel:${deal.customer.phone}`}
                      disabled={!deal.customer.phone}
                    >
                      G·ªçi
                    </Button>,
                  ]}
                >
                  <List.Item.Meta
                    title={
                      <Space>
                        {/* Priority Badge */}
                        <Tag color={priorityConfig?.color || "default"}>
                          {deal.followUpPriority || "NORMAL"}
                        </Tag>

                        {/* Customer Name */}
                        <Text strong>{deal.customer.fullName}</Text>

                        {/* Overdue/Today Badge */}
                        {isOverdue && <Tag color="red">Qu√° h·∫°n</Tag>}
                        {isToday && <Tag color="orange">H√¥m nay</Tag>}
                      </Space>
                    }
                    description={
                      <Space direction="vertical" size={4}>
                        <Text>
                          <strong>D·ªãch v·ª•:</strong> {deal.dentalService.name}
                        </Text>
                        <Text>
                          <strong>SƒêT:</strong>{" "}
                          {deal.customer.phone || "Ch∆∞a c√≥"}
                        </Text>
                        <Space>
                          <Text>
                            <CalendarOutlined />{" "}
                            {followUpDate.format("DD/MM/YYYY HH:mm")}
                          </Text>
                          <Tag color={stageConfig?.color}>
                            {stageConfig?.label || deal.stage}
                          </Tag>
                          {deal.saleOnline && (
                            <Text type="secondary">
                              Sale: {deal.saleOnline.fullName}
                            </Text>
                          )}
                        </Space>
                      </Space>
                    }
                  />
                </List.Item>
              );
            }}
          />
        ) : (
          <Empty
            description={`Kh√¥ng c√≥ deal n√†o c·∫ßn follow-up v√†o ${dayjs(
              selectedDate
            ).format("DD/MM/YYYY")}`}
          />
        )}
      </Card>
    </div>
  );
}
```

---

#### B. API Helper

**File:** `src/features/consulted-services/api/index.ts`

```typescript
export async function getDealsForFollowUpApi(params: {
  date: Date;
  saleId?: string;
  clinicId?: string;
}) {
  const searchParams = new URLSearchParams();
  searchParams.set("date", params.date.toISOString());
  if (params.saleId) searchParams.set("saleId", params.saleId);
  if (params.clinicId) searchParams.set("clinicId", params.clinicId);

  const response = await fetch(
    `/api/v1/consulted-services/follow-ups?${searchParams}`
  );
  if (!response.ok) {
    throw new Error("Failed to fetch deals for follow-up");
  }
  const json = await response.json();
  return json.data;
}
```

---

#### C. Route Integration

**File:** `src/app/(private)/follow-ups/page.tsx`

```tsx
import { FollowUpDashboardView } from "@/features/follow-ups/views/FollowUpDashboardView";

export default function FollowUpPage() {
  return <FollowUpDashboardView />;
}
```

**Add to navigation:**

```typescript
// src/layouts/components/MainMenu.tsx
{
  key: "follow-ups",
  label: "Follow-up",
  icon: <PhoneOutlined />,
  path: "/follow-ups",
}
```

---

#### D. Usage Examples

**Sales user flow:**

1. Sales login ‚Üí Auto navigate to Follow-up Dashboard
2. Th·∫•y 5 deals c·∫ßn g·ªçi h√¥m nay
3. Click "G·ªçi" ‚Üí Phone app m·ªü v·ªõi s·ªë ƒëi·ªán tho·∫°i
4. Sau khi g·ªçi xong ‚Üí Update stage ho·∫∑c reschedule follow-up

**Manager user flow:**

1. Manager m·ªü Follow-up Dashboard
2. Ch·ªçn "T·∫•t c·∫£ sales" ‚Üí Th·∫•y t·ªïng quan
3. Ch·ªçn sale c·ª• th·ªÉ ‚Üí Ki·ªÉm tra c√¥ng vi·ªác c·ªßa sale ƒë√≥
4. Th·∫•y deals qu√° h·∫°n ‚Üí Nh·∫Øc nh·ªü sale

---

## üéØ 2-PHASE KANBAN VIEWS

### Concept: Online View vs Offline View

**Purpose:** T√°ch ri√™ng 2 m√†n h√¨nh Kanban ƒë·ªÉ ph√π h·ª£p v·ªõi workflow th·ª±c t·∫ø:

- **Online View**: Sale Online (telesale) ch·ªâ th·∫•y c√°c c·ªôt Lead Pipeline
- **Offline View**: Sale Offline + B√°c sƒ© th·∫•y c√°c c·ªôt Opportunity Pipeline

---

### A. Online View (Lead Pipeline)

**Audience:** Sale Online (Telesale)

**Goal:** K√©o kh√°ch ƒë·∫øn ph√≤ng kh√°m (target = ARRIVED)

**Kanban Columns:**

| Column       | Stage      | Description                                                  | Actions                               |
| ------------ | ---------- | ------------------------------------------------------------ | ------------------------------------- |
| M·ªõi          | NEW        | Data m·ªõi ƒë·ªï v·ªÅ, ch∆∞a ai ƒë·ª•ng                                 | ‚Üí K√©o sang CONTACTING khi b·∫Øt ƒë·∫ßu g·ªçi |
| ƒêang li√™n h·ªá | CONTACTING | ƒê√£ g·ªçi/nh·∫Øn nh∆∞ng ch∆∞a ch·ªët l·ªãch                             | ‚Üí SCHEDULED (ch·ªët l·ªãch) ho·∫∑c LOST     |
| ƒê√£ ƒë·∫∑t l·ªãch  | SCHEDULED  | Kh√°ch ƒë·ªìng √Ω ƒë·∫øn kh√°m v√†o gi·ªù c·ª• th·ªÉ                         | ‚Üí ARRIVED (kh√°ch ƒë·∫øn) ho·∫∑c LOST       |
| ƒê√£ ƒë·∫øn       | ARRIVED    | ‚úÖ **KPI Sale Online** - Kh√°ch ƒë√£ c√≥ m·∫∑t                     | ‚Üí Chuy·ªÉn sang Opportunity Pipeline    |
| Th·∫•t b·∫°i     | LOST       | Sai s·ªë, d·∫≠p m√°y, h·ªßy l·ªãch (c√≥ th·ªÉ x·∫£y ra ·ªü b·∫•t k·ª≥ stage n√†o) | ‚ùå End state                          |

**Route:** `/leads` ho·∫∑c `/online-pipeline`

**Implementation:**

```tsx
export function LeadPipelineKanbanView() {
  const { data: dealsByStage } = useDealsByStage({
    stages: ["NEW", "CONTACTING", "SCHEDULED", "ARRIVED", "LOST"],
    saleOnlineId: currentUser.employeeId, // Filter by current sale online
  });

  const columns = [
    { key: "NEW", title: "M·ªõi", color: "blue" },
    { key: "CONTACTING", title: "ƒêang li√™n h·ªá", color: "cyan" },
    { key: "SCHEDULED", title: "ƒê√£ ƒë·∫∑t l·ªãch", color: "geekblue" },
    { key: "ARRIVED", title: "ƒê√£ ƒë·∫øn ‚úÖ", color: "purple" },
    { key: "LOST", title: "Th·∫•t b·∫°i", color: "red" },
  ];

  // Statistics
  const arrivedCount = dealsByStage?.ARRIVED?.length || 0;
  const lostCount = dealsByStage?.LOST?.length || 0;
  const conversionRate = (arrivedCount / (arrivedCount + lostCount)) * 100;

  return (
    <div>
      <Title level={2}>Lead Pipeline (Sale Online)</Title>

      {/* KPI Cards */}
      <Row gutter={16}>
        <Col span={8}>
          <Card>
            <Statistic
              title="ƒê√£ ƒë·∫øn (KPI)"
              value={arrivedCount}
              valueStyle={{ color: "#3f8600" }}
            />
          </Card>
        </Col>
        <Col span={8}>
          <Card>
            <Statistic
              title="Th·∫•t b·∫°i"
              value={failedCount}
              valueStyle={{ color: "#cf1322" }}
            />
          </Card>
        </Col>
        <Col span={8}>
          <Card>
            <Statistic
              title="T·ª∑ l·ªá chuy·ªÉn ƒë·ªïi"
              value={conversionRate}
              suffix="%"
              precision={1}
            />
          </Card>
        </Col>
      </Row>

      {/* Kanban Board */}
      <KanbanBoard
        columns={columns}
        data={dealsByStage}
        onDragEnd={(dealId, newStage) => updateStage(dealId, newStage)}
      />
    </div>
  );
}
```

---

### B. Offline View (Opportunity Pipeline)

**Audience:** Sale Offline + B√°c sƒ© + L·ªÖ t√¢n

**Goal:** Ch·ªët ti·ªÅn v√† ƒëi·ªÅu tr·ªã (target = DEPOSIT ‚Üí TREATING)

**Kanban Columns:**

| Column        | Stage      | Description                                                     | Actions                         |
| ------------- | ---------- | --------------------------------------------------------------- | ------------------------------- |
| H√†ng ƒë·ª£i      | ARRIVED    | Kh√°ch ƒë√£ ƒë·∫øn, ch·ªù g·∫∑p b√°c sƒ©                                    | ‚Üí CONSULTING (b·∫Øt ƒë·∫ßu kh√°m)     |
| ƒêang t∆∞ v·∫•n   | CONSULTING | B√°c sƒ© ƒëang kh√°m, ch·ª•p X-quang, l√™n ph√°c ƒë·ªì                     | ‚Üí QUOTED (b√°o gi√°) ho·∫∑c LOST    |
| ƒê√£ b√°o gi√°    | QUOTED     | ƒê√£ ƒë∆∞a ra con s·ªë, kh√°ch ƒëang c√¢n nh·∫Øc                           | ‚Üí DEPOSIT (ch·ªët ti·ªÅn) ho·∫∑c LOST |
| ƒê√£ c·ªçc ‚úÖ     | DEPOSIT    | **WIN** - Kh√°ch ƒë√£ xu·ªëng ti·ªÅn c·ªçc                               | ‚Üí TREATING (b·∫Øt ƒë·∫ßu ƒëi·ªÅu tr·ªã)   |
| ƒêang ƒëi·ªÅu tr·ªã | TREATING   | Qu√° tr√¨nh ƒëi·ªÅu tr·ªã ƒëang di·ªÖn ra                                 | Post-WIN state                  |
| Th·∫•t b·∫°i      | LOST       | Kh√°ch kh√¥ng ƒë·ªìng √Ω, h·ªßy deal (c√≥ th·ªÉ x·∫£y ra ·ªü b·∫•t k·ª≥ stage n√†o) | ‚ùå End state                    |

**Route:** `/opportunities` ho·∫∑c `/offline-pipeline`

**Implementation:**

```tsx
export function OpportunityPipelineKanbanView() {
  const { data: dealsByStage } = useDealsByStage({
    stages: ["ARRIVED", "CONSULTING", "QUOTED", "DEPOSIT", "TREATING", "LOST"],
    clinicId: currentUser.clinicId,
  });

  const columns = [
    { key: "ARRIVED", title: "H√†ng ƒë·ª£i", color: "purple" },
    { key: "CONSULTING", title: "ƒêang t∆∞ v·∫•n", color: "orange" },
    { key: "QUOTED", title: "ƒê√£ b√°o gi√°", color: "gold" },
    { key: "DEPOSIT", title: "ƒê√£ c·ªçc ‚úÖ", color: "green" },
    { key: "TREATING", title: "ƒêang ƒëi·ªÅu tr·ªã", color: "lime" },
    { key: "LOST", title: "Th·∫•t b·∫°i", color: "red" },
  ];

  // Statistics
  const depositCount = dealsByStage?.DEPOSIT?.length || 0;
  const treatingCount = dealsByStage?.TREATING?.length || 0;
  const quotedCount = dealsByStage?.QUOTED?.length || 0;
  const closingRate = (depositCount / quotedCount) * 100;

  return (
    <div>
      <Title level={2}>Opportunity Pipeline (Sale Offline)</Title>

      {/* KPI Cards */}
      <Row gutter={16}>
        <Col span={6}>
          <Card>
            <Statistic
              title="ƒê√£ c·ªçc"
              value={depositCount}
              valueStyle={{ color: "#3f8600" }}
            />
          </Card>
        </Col>
        <Col span={6}>
          <Card>
            <Statistic title="ƒêang ƒëi·ªÅu tr·ªã" value={treatingCount} />
          </Card>
        </Col>
        <Col span={6}>
          <Card>
            <Statistic title="ƒê√£ b√°o gi√°" value={quotedCount} />
          </Card>
        </Col>
        <Col span={6}>
          <Card>
            <Statistic
              title="T·ª∑ l·ªá ch·ªët"
              value={closingRate}
              suffix="%"
              precision={1}
            />
          </Card>
        </Col>
      </Row>

      {/* Kanban Board */}
      <KanbanBoard
        columns={columns}
        data={dealsByStage}
        onDragEnd={(dealId, newStage) => updateStage(dealId, newStage)}
      />
    </div>
  );
}
```

---

### C. Role-Based Access

**Permission Matrix:**

| Role         | Can View      | Can Edit                                    |
| ------------ | ------------- | ------------------------------------------- |
| Sale Online  | Lead Pipeline | NEW ‚Üí CONTACTING ‚Üí SCHEDULED ‚Üí ARRIVED/LOST |
| Sale Offline | Opportunity   | ARRIVED ‚Üí CONSULTING ‚Üí QUOTED ‚Üí DEPOSIT     |
| Doctor       | Opportunity   | CONSULTING ‚Üí QUOTED                         |
| Receptionist | Both          | ARRIVED (check-in) only                     |
| Manager      | Both          | All stages (read-only)                      |

**Implementation:**

```typescript
// src/features/consulted-services/utils/permissions.ts

export function canAccessLeadPipeline(user: UserCore): boolean {
  return ["admin", "sale_online"].includes(user.role);
}

export function canAccessOpportunityPipeline(user: UserCore): boolean {
  return ["admin", "sale_offline", "doctor", "receptionist"].includes(
    user.role
  );
}

export function canUpdateStage(
  user: UserCore,
  fromStage: string,
  toStage: string
): boolean {
  // Sale Online: Lead pipeline stages + LOST
  if (user.role === "sale_online") {
    const leadStages = ["NEW", "CONTACTING", "SCHEDULED", "ARRIVED", "LOST"];
    return leadStages.includes(fromStage) && leadStages.includes(toStage);
  }

  // Sale Offline: Opportunity pipeline stages + LOST
  if (user.role === "sale_offline") {
    const opportunityStages = [
      "ARRIVED",
      "CONSULTING",
      "QUOTED",
      "DEPOSIT",
      "TREATING",
      "LOST", // Offline c≈©ng c√≥ th·ªÉ mark deal as LOST
    ];
    return (
      opportunityStages.includes(fromStage) &&
      opportunityStages.includes(toStage)
    );
  }

  // Doctor: Only consulting/quoted
  if (user.role === "doctor") {
    return (
      ["CONSULTING", "QUOTED"].includes(fromStage) &&
      ["CONSULTING", "QUOTED"].includes(toStage)
    );
  }

  // Receptionist: Only check-in (mark as ARRIVED)
  if (user.role === "receptionist") {
    return fromStage === "SCHEDULED" && toStage === "ARRIVED";
  }

  // Admin: All stages
  return user.role === "admin";
}
```

---

### D. Navigation & Routing

**Menu Items:**

```typescript
// src/layouts/components/MainMenu.tsx

const menuItems = [
  // Sale Online sees Lead Pipeline
  canAccessLeadPipeline(user) && {
    key: "lead-pipeline",
    label: "Lead Pipeline",
    icon: <PhoneOutlined />,
    path: "/leads",
  },

  // Sale Offline/Doctor sees Opportunity Pipeline
  canAccessOpportunityPipeline(user) && {
    key: "opportunity-pipeline",
    label: "Opportunity Pipeline",
    icon: <DollarOutlined />,
    path: "/opportunities",
  },

  // Manager sees combined view (optional)
  user.role === "admin" && {
    key: "full-pipeline",
    label: "Full Pipeline",
    icon: <FundOutlined />,
    path: "/pipeline",
  },
].filter(Boolean);
```

**Routes:**

```tsx
// src/app/(private)/leads/page.tsx
export default function LeadPipelinePage() {
  return <LeadPipelineKanbanView />;
}

// src/app/(private)/opportunities/page.tsx
export default function OpportunityPipelinePage() {
  return <OpportunityPipelineKanbanView />;
}
```

---

### E. API Updates for Stage Filtering

**Repository Method:**

```typescript
// src/server/repos/consulted-service.repo.ts

async findByStages(params: {
  stages: string[]; // ‚≠ê Filter by specific stages only
  clinicId?: string;
  saleOnlineId?: string;
  consultingSaleId?: string;
  dateFrom?: Date;
  dateTo?: Date;
}) {
  return prisma.consultedService.findMany({
    where: {
      stage: { in: params.stages }, // ‚≠ê Only fetch specified stages
      clinicId: params.clinicId,
      saleOnlineId: params.saleOnlineId,
      consultingSaleId: params.consultingSaleId,
      createdAt: {
        gte: params.dateFrom,
        lte: params.dateTo,
      },
    },
    include: {
      customer: { select: { id: true, fullName: true, phone: true } },
      dentalService: { select: { id: true, name: true } },
      saleOnline: { select: { id: true, fullName: true } },
      consultingSale: { select: { id: true, fullName: true } },
    },
    orderBy: [
      { stage: "asc" },
      { createdAt: "desc" },
    ],
  });
}
```

**API Route:**

```typescript
// src/app/api/v1/consulted-services/by-stage/route.ts

export async function GET(req: Request) {
  try {
    const user = await getSessionUser();
    const { searchParams } = new URL(req.url);

    // ‚≠ê Accept stages as comma-separated list
    const stagesParam = searchParams.get("stages");
    const stages = stagesParam ? stagesParam.split(",") : undefined;

    const params = {
      stages, // ‚≠ê Filter by specific stages
      clinicId: searchParams.get("clinicId") || user.clinicId,
      saleOnlineId: searchParams.get("saleOnlineId") || undefined,
      consultingSaleId: searchParams.get("consultingSaleId") || undefined,
      dateFrom: searchParams.get("dateFrom")
        ? new Date(searchParams.get("dateFrom")!)
        : undefined,
      dateTo: searchParams.get("dateTo")
        ? new Date(searchParams.get("dateTo")!)
        : undefined,
    };

    const result = await consultedServiceRepo.findByStages(params);

    // Group by stage
    const grouped = result.reduce((acc, deal) => {
      if (!acc[deal.stage]) {
        acc[deal.stage] = [];
      }
      acc[deal.stage].push(deal);
      return acc;
    }, {} as Record<string, typeof result>);

    return NextResponse.json({ success: true, data: grouped });
  } catch (error) {
    return handleApiError(error);
  }
}
```

**Hook Usage:**

```typescript
// src/features/consulted-services/hooks/useDealsByStage.ts

export function useDealsByStage(params: {
  stages?: string[];
  clinicId?: string;
  saleOnlineId?: string;
  consultingSaleId?: string;
}) {
  return useQuery({
    queryKey: CONSULTED_SERVICE_QUERY_KEYS.byStage(params),
    queryFn: () => getDealsByStageApi(params),
    staleTime: 60 * 1000, // 1 minute
    gcTime: 5 * 60 * 1000, // 5 minutes
  });
}

// API Helper
async function getDealsByStageApi(params: {
  stages?: string[];
  clinicId?: string;
  saleOnlineId?: string;
  consultingSaleId?: string;
}) {
  const searchParams = new URLSearchParams();
  if (params.stages) searchParams.set("stages", params.stages.join(","));
  if (params.clinicId) searchParams.set("clinicId", params.clinicId);
  if (params.saleOnlineId)
    searchParams.set("saleOnlineId", params.saleOnlineId);
  if (params.consultingSaleId)
    searchParams.set("consultingSaleId", params.consultingSaleId);

  const response = await fetch(
    `/api/v1/consulted-services/by-stage?${searchParams}`
  );
  if (!response.ok) throw new Error("Failed to fetch deals by stage");
  const json = await response.json();
  return json.data;
}
```

---

## üß™ TESTING

### Backend Tests

**File:** `src/server/services/consulted-service.service.test.ts`

**Test cases:**

- ‚úÖ Create deal with source (required)
- ‚úÖ Create deal with default stage = "NEW"
- ‚úÖ Update stage to LOST (requires lostReason)
- ‚úÖ Update stage to TREATING (sets wonDate automatically)
- ‚úÖ DEPOSIT does not set wonDate (can still be cancelled)
- ‚úÖ Update follow-up fields
- ‚úÖ Filter deals by stage (2-phase pipeline)
- ‚úÖ Filter deals by source
- ‚úÖ Get active deals for follow-up (stage NOT IN ['LOST', 'TREATING']) - includes DEPOSIT
- ‚úÖ Filter deals by stages array (for Online/Offline views)
- ‚úÖ LOST can happen in both Lead and Opportunity pipelines
- ‚úÖ DEPOSIT can transition to LOST (customer cancels after deposit)
- ‚úÖ Only TREATING is final success state

### Frontend Tests

**Test cases:**

- ‚úÖ ConsultedServiceFormModal shows all new fields
- ‚úÖ Source field is required
- ‚úÖ Lost reason required when stage = LOST
- ‚úÖ ConsultedServiceTable shows new columns
- ‚úÖ Follow-up column shows overdue/today badges (for active deals including DEPOSIT)
- ‚úÖ UpdateFollowUpModal updates fields
- ‚úÖ StageUpdateModal updates stage (with lostReason validation)
- ‚úÖ LeadPipelineKanbanView shows lead stages + LOST (NEW ‚Üí ARRIVED/LOST)
- ‚úÖ OpportunityPipelineKanbanView shows opportunity stages + LOST (ARRIVED ‚Üí TREATING/LOST)
- ‚úÖ Role-based permissions: Sale Online can mark deal as LOST
- ‚úÖ Role-based permissions: Sale Offline can also mark deal as LOST
- ‚úÖ LOST stage can be set from any active stage in both pipelines
- ‚úÖ DEPOSIT stage can transition to TREATING (start treatment) or LOST (cancel)
- ‚úÖ Only TREATING shows "Th√†nh c√¥ng" section in DetailView
- ‚úÖ DEPOSIT shows "ƒê·∫∑t c·ªçc" section with warning about possible cancellation

---

## üì¶ ROLLOUT PLAN

### Phase 1: Database MigratRequestSchema (add source, stage, follow-up fields)

- [ ] ConsultedServiceUpdateRequestSchema (partial updates)
- [ ] UpdateStageRequestSchema (stage + lostReason validation)
- [ ] UpdateFollowUpRequestSchema (priority + date)
- [ ] ConsultedServiceResponseSchema (nested structur

### Phase 2: Backend Updates (2-3 days)

- [ ] Update validation schemas (source, stage, follow-up fields)
- [ ] Update repository queries (filters, new methods)
- [ ] Update service methods (create, update, stage transitions)
- [ ] Add server actions (updateStage, updateFollowUp)
- [ ] Add API routes (follow-ups, by-stage)

### Phase 3: Frontend Updates (3-4 days)

- [ ] Update ConsultedServiceFormModal (6 new fields)
- [ ] Update ConsultedServiceTable (5 new columns + filters)
- [ ] Update ConsultedServiceDetailView (3 new sections)
- [ ] Create UpdaCONSULTED_SERVICE_QUERY_KEYS, PIPELINE_STAGE_OPTIONS, DEAL_SOURCE_OPTIONS, MESSAGES)
- [ ] ConsultedServiceFormModal (6 new fields)
- [ ] ConsultedServiceTable (5 new columns)
- [ ] ConsultedServiceTable (2 new filters)
- [ ] ConsultedServiceDetailView (deal source section)
- [ ] ConsultedServiceDetailView (follow-up section)
- [ ] ConsultedServiceDetailView (lost reason section)
- [ ] UpdateFollowUpModal component
- [ ] StageUpdateModal component
- [ ] useUpdateStage hook (v·ªõi useNotify + query keys)
- [ ] useUpdateFollowUp hook (v·ªõi useNotify + query keys)
- [ ] useDealsForFollowUp hook (v·ªõi caching strategy)

---

## üìã IMPLEMENTATION CHECKLIST

**Backend:** üîÑ IN PROGRESS

- [ ] ConsultedServiceCreateSchema (add source, stage, follow-up fields)
- [ ] ConsultedServiceUpdateSchema (partial updates)
- [ ] UpdateStageSchema (stage + lostReason validation)
- [ ] UpdateFollowUpSchema (priority + date)
- [ ] Repository: create method (default stage)
- [ ] Repository: list method (add filters)
- [ ] Repository: findDealsForFollowUp method
- [ ] Repository: findByStage method
- [ ] Service: create method (validate source)
- [ ] Service: update method (handle stage transitions)
- [ ] Service: updateStage method (for Kanban)
- [ ] Service: updateFollowUp method (for scheduling)
- [ ] Server actions (updateStage, updateFollowUp)
- [ ] API routes (follow-ups, by-stage)

**Frontend:** üîÑ IN PROGRESS

- [ ] Constants (PIPELINE_STAGE_OPTIONS with 2 phases, DEAL_SOURCE_OPTIONS)
- [ ] ConsultedServiceFormModal (6 new fields)
- [ ] ConsultedServiceTable (5 new columns)
- [ ] ConsultedServiceTable (2 new filters)
- [ ] ConsultedServiceDetailView (deal source section)
- [ ] ConsultedServiceDetailView (follow-up section)
- [ ] ConsultedServiceDetailView (failed/won status sections)
- [ ] UpdateFollowUpModal component
- [ ] StageUpdateModal component (with failedReason validation)
- [ ] useUpdateStage hook
- [ ] useUpdateFollowUp hook
- [ ] useDealsForFollowUp hook
- [ ] useDealsByStage hook (with stages filter)

**2-Phase Kanban Views:** ‚è≥ TODO

- [ ] LeadPipelineKanbanView (Online View: NEW ‚Üí ARRIVED/FAILED)
- [ ] OpportunityPipelineKanbanView (Offline View: ARRIVED ‚Üí TREATING)
- [ ] Role-based permissions (canUpdateStage function)
- [ ] API route: GET /by-stage with stages filter
- [ ] Repository: findByStages method
- [ ] Navigation menu items (conditional by role)

**Features:** ‚è≥ TODO

- [ ] Source field required on create
- [ ] Stage defaults to NEW on create
- [ ] Lost reason required when stage = LOST
- [ ] Auto-set wonDate when stage = TREATING (not DEPOSIT)
- [ ] Auto-set lostDate when stage = LOST
- [ ] Follow-up shown for active deals (NOT ['LOST', 'TREATING']) - includes DEPOSIT
- [ ] Overdue/today badges on follow-up column
- [ ] Filter by source and stage
- [ ] Quick update modals (stage, follow-up)
- [ ] Sale Online can mark deal as LOST (Lead Pipeline)
- [ ] Sale Offline can mark deal as LOST (Opportunity Pipeline)
- [ ] DEPOSIT can transition to TREATING or LOST
- [ ] Only TREATING is final success state
- [ ] DEPOSIT shows warning about possible cancellation

---

## üöÄ SUMMARY

**Status:** üìù PLANNING

**Scope:** Comprehensive refactor of ConsultedService feature to support deal-centric CRM with 2-Phase Real-World Pipeline

**Database Changes (from 119 FINAL):**

- Added fields: source, sourceNotes, stage, followUpPriority, nextFollowUpDate, saleOnlineId, lostReason, lostDate, wonDate
- Index: (stage, nextFollowUpDate) for follow-up queries
- **NEW**: 2-Phase Pipeline stages (9 stages total):
  - **Phase 1 (Lead)**: NEW, CONTACTING, SCHEDULED, ARRIVED
  - **Phase 2 (Opportunity)**: CONSULTING, QUOTED, DEPOSIT, TREATING
  - **End State**: LOST (c√≥ th·ªÉ x·∫£y ra ·ªü b·∫•t k·ª≥ stage n√†o trong c·∫£ 2 phases)

**Backend Implementation:**

- 4 validation schemas (Create, Update, UpdateStage, UpdateFollowUp)
- 4 new repo methods (findDealsForFollowUp, findByStage, findByStages, handle stage transitions)
- 3 new service methods (create with source, updateStage, updateFollowUp)
- 2 new server actions (updateStage, updateFollowUp)
- 2 new API routes (follow-ups, by-stage with stages filter)

**Frontend Implementation:**

- ConsultedServiceFormModal: 6 new fields (source, sourceNotes, stage, priority, nextFollowUpDate, saleOnlineId, lostReason)
- ConsultedServiceTable: 5 new columns (source, stage, follow-up, saleOnline, priority badges)
- ConsultedServiceDetailView: 3 new sections (deal source, follow-up, lost/won status)
- 2 new modal components (UpdateFollowUpModal, StageUpdateModal)
- 4 new React Query hooks (useUpdateStage, useUpdateFollowUp, useDealsForFollowUp, useDealsByStage)
- **NEW**: 2 Kanban Views:
  - **LeadPipelineKanbanView**: Sale Online view (NEW ‚Üí ARRIVED/FAILED)
  - **OpportunityPipelineKanbanView**: Sale Offline view (ARRIVED ‚Üí TREATING)
- **NEW**: Role-based permissions system

**Key Features:**

- Deal source tracking (campaign attribution)
- **2-Phase Pipeline stage management**:
  - **Lead Pipeline** (Sale Online): NEW ‚Üí CONTACTING ‚Üí SCHEDULED ‚Üí ARRIVED
  - **Opportunity Pipeline** (Sale Offline/Doctor): ARRIVED ‚Üí CONSULTING ‚Üí QUOTED ‚Üí DEPOSIT ‚Üí TREATING
  - **End States**: LOST (c√≥ th·ªÉ x·∫£y ra ·ªü b·∫•t k·ª≥ stage n√†o), TREATING (th√†nh c√¥ng cu·ªëi c√πng)
- Follow-up scheduling (priority + date)
- Active vs completed deals:
  - **Active** = NOT IN ['LOST', 'TREATING'] - bao g·ªìm DEPOSIT v√¨ c√≥ th·ªÉ h·ªßy
  - **Won** = 'TREATING' only - ch·ªâ khi ƒë√£ b·∫Øt ƒë·∫ßu ƒëi·ªÅu tr·ªã
  - **Lost** = 'LOST'
- Lost deal tracking (reason + date) - c√≥ th·ªÉ x·∫£y ra ·ªü c·∫£ 2 phases
- Won deal tracking (wonDate when TREATING, not DEPOSIT)
- **DEPOSIT logic**: ƒê√£ c·ªçc nh∆∞ng v·∫´n c√≥ th·ªÉ h·ªßy ‚Üí chuy·ªÉn sang TREATING (th√†nh c√¥ng) ho·∫∑c LOST (h·ªßy)
- Multiple sales roles (saleOnlineId for telesale, consultingSaleId for offline)
- **Role-based Kanban views** (Online vs Offline) - c·∫£ 2 view ƒë·ªÅu c√≥ th·ªÉ mark deal as LOST

**Dependencies:**

- 119 FINAL: Schema changes
- 120.1: Customer Updates completed

**Next Steps:**

1. Backend implementation (2-3 days)
2. Frontend implementation (3-4 days)
3. Integration testing (1-2 days)
4. Ready for Phase 2: Generic Kanban Component
