# üîÑ Phase 0.1.1: Customer Updates for Lead Integration

> **Date**: 2025-12-13  
> **Status**: üìù PROPOSAL - Waiting for approval  
> **Parent**: 120 Lead Management System  
> **Scope**: Customer model and view updates to support Lead workflow

---

## üìä OVERVIEW

C·∫≠p nh·∫≠t **Customer model v√† views** ƒë·ªÉ h·ªó tr·ª£ Lead workflow:

1. ‚úÖ Add `type` field to distinguish LEAD vs CUSTOMER
2. ‚úÖ Add `note` and `firstVisitDate` fields
3. ‚úÖ Update Customer repo/service to filter by `type="CUSTOMER"`
4. ‚úÖ Add Convert Lead modal (LEAD ‚Üí CUSTOMER)
5. ‚úÖ Update table columns (show type, firstVisitDate)

**Business Context:**

- Customer model ƒë∆∞·ª£c share v·ªõi Lead (same table)
- Customer repo/service ch·ªâ l√†m vi·ªác v·ªõi `type="CUSTOMER"`
- Reception c·∫ßn t√¨m Lead v√† convert th√†nh Customer khi check-in

---

## üóÑÔ∏è SCHEMA CHANGES

### Customer Model Updates

```prisma
model Customer {
  id   String @id @default(uuid())

  // ‚≠ê NEW: Type field distinguishes LEAD vs CUSTOMER
  type String // "LEAD" | "CUSTOMER" (backend validation)

  // ‚≠ê NEW: General notes field
  note String?

  // ‚≠ê NEW: First visit date (for CUSTOMER only, NULL for LEAD)
  firstVisitDate DateTime? @db.Timestamptz

  // EXISTING: Conditional fields based on type
  customerCode   String?   @unique      // NULL for LEAD, auto-generated for CUSTOMER
  clinicId       String?                // NULL for LEAD, required for CUSTOMER

  // ... all other existing fields unchanged

  @@index([type, clinicId, createdAt])
  @@index([phone])
  @@map("Customer")
}
```

**Migration:**

```prisma
-- Add new fields to Customer table
ALTER TABLE "Customer" ADD COLUMN "type" TEXT NOT NULL DEFAULT 'CUSTOMER';
ALTER TABLE "Customer" ADD COLUMN "note" TEXT;
ALTER TABLE "Customer" ADD COLUMN "firstVisitDate" TIMESTAMPTZ;

-- Create indexes
CREATE INDEX "Customer_type_clinicId_createdAt_idx" ON "Customer"("type", "clinicId", "createdAt");
CREATE INDEX "Customer_phone_idx" ON "Customer"("phone");

-- Set all existing records to CUSTOMER type
UPDATE "Customer" SET "type" = 'CUSTOMER' WHERE "type" IS NULL;

-- Set firstVisitDate for existing customers (use createdAt as fallback)
UPDATE "Customer" SET "firstVisitDate" = "createdAt" WHERE "firstVisitDate" IS NULL AND "type" = 'CUSTOMER';
```

---

## üîß BACKEND CHANGES

### 1. Update Customer Validation Schema

**File:** `src/shared/validation/customer.schema.ts`

#### A. Update CustomerCommonFieldsSchema

**Add:**

```typescript
const CustomerCommonFieldsSchema = z.object({
  // ... existing fields

  // ‚≠ê NEW: General notes
  note: z.string().trim().optional().nullable(),
});
```

#### B. Update CustomerResponseSchema

**Add:**

```typescript
export const CustomerResponseSchema = z.object({
  // ... existing fields

  // ‚≠ê NEW: Type discriminator
  type: z.string(), // "LEAD" | "CUSTOMER"

  // ‚≠ê NEW: First visit date
  firstVisitDate: z.string().datetime().nullable(),
});
```

> **Note**: CreateCustomerRequestSchema v√† UpdateCustomerRequestSchema kh√¥ng c·∫ßn thay ƒë·ªïi - ch√∫ng extend t·ª´ CustomerCommonFieldsSchema n√™n t·ª± ƒë·ªông c√≥ field `note`

---

### 2. Update Customer Repository

**File:** `src/server/repos/customer.repo.ts`

**Add `type="CUSTOMER"` filter to all queries:**

```typescript
export const customerRepo = {
  // ‚≠ê UPDATE: Create - Set type="CUSTOMER"
  async create(data: Prisma.CustomerCreateInput) {
    return prisma.customer.create({
      data: {
        ...data,
        type: "CUSTOMER", // ‚≠ê Always CUSTOMER
      },
      include: {
        /* ... */
      },
    });
  },

  // ‚≠ê UPDATE: List - Add type filter
  async list(params: {
    /* ... */
  }) {
    const where: Prisma.CustomerWhereInput = {
      type: "CUSTOMER", // ‚≠ê Filter only CUSTOMER
      // ... rest of filters
    };

    return prisma.customer.findMany({ where /* ... */ });
  },

  // ‚≠ê UPDATE: findById - Add type filter
  async findById(id: string) {
    return prisma.customer.findFirst({
      where: {
        id,
        type: "CUSTOMER", // ‚≠ê Filter
      },
      include: {
        /* ... */
      },
    });
  },

  // ‚≠ê UPDATE: findByPhone - Add type filter
  async findByPhone(phone: string) {
    return prisma.customer.findFirst({
      where: {
        phone,
        type: "CUSTOMER", // ‚≠ê Filter
      },
    });
  },

  // ‚≠ê UPDATE: All other methods
  // - listDaily() - Add type="CUSTOMER" filter
  // - findByEmail() - Add type="CUSTOMER" filter
  // - update() - No filter needed (already validated by findById)
  // - delete() - No filter needed (already validated by findById)
};
```

---

### 3. Update Customer Service

**File:** `src/server/services/customer.service.ts`

**Update `create()` to set `firstVisitDate`:**

```typescript
export const customerService = {
  // ‚≠ê UPDATE: create() - Set firstVisitDate
  async create(currentUser: UserCore | null, body: unknown) {
    // ... all existing validation logic ...

    // ‚≠ê Create Customer with firstVisitDate
    const customer = await customerRepo.create({
      ...data,
      customerCode, // Generated (existing)
      firstVisitDate: new Date(), // ‚≠ê NEW - Set first visit date
      createdById: currentUser.employeeId!,
      updatedById: currentUser.employeeId!,
      // type: "CUSTOMER" is set in customerRepo.create()
    });

    // ... rest unchanged (primary contact, etc.) ...
    return mapCustomerToResponse(result);
  },

  // ‚≠ê All other methods: No changes needed
  // Repo layer automatically filters by type="CUSTOMER"
  // - list()
  // - update()
  // - delete()
  // - getById()
  // - daily()
};
```

---

### 4. Customer Server Actions

**File:** `src/server/actions/customer.actions.ts`

**‚úÖ NO CHANGES** - All existing actions stay the same. `createCustomerAction()` automatically sets `firstVisitDate` via service layer.

---

### 5. Customer API Routes

**Files:** `src/app/api/v1/customers/*.ts`

**‚úÖ NO CHANGES** - All existing routes stay the same:

- `GET /api/v1/customers` - works as before
- `GET /api/v1/customers/[id]` - works as before
- `GET /api/v1/customers/daily` - works as before

---

## üé® FRONTEND CHANGES

### 1. ConvertLeadModal Component

**File:** NEW `src/features/customers/components/ConvertLeadModal.tsx`

**Purpose:** Convert LEAD ‚Üí CUSTOMER when reception check-in

**Form Fields:**

- **Read-only section** (t·ª´ Lead):
  - SƒêT, H·ªç t√™n, T·ªânh/TP, Ngu·ªìn (display only)
- **Required fields**:
  - C∆° s·ªü (clinicId) - dropdown
- **Optional fields**:
  - Ng√†y sinh (dateOfBirth)
  - Gi·ªõi t√≠nh (gender)
  - ƒê·ªãa ch·ªâ (address)
  - Email

**Action:** `convertLeadToCustomerAction(leadId, data)` (from Lead feature)

**Auto-generated** (backend):

- customerCode (m√£ KH)
- firstVisitDate (h√¥m nay)
- type: "LEAD" ‚Üí "CUSTOMER"

**Follow CustomerFormModal pattern:**

- Width: 65% viewport
- Grid layout: Row with gutter={12}
- Same validation and error handling

---

### 2. CustomerTable Column Updates

**File:** `src/features/customers/components/CustomerTable.tsx`

**Current columns:**

- M√£ KH, H·ªç t√™n, SƒêT, Ng∆∞·ªùi li√™n h·ªá, D·ªãch v·ª• quan t√¢m, Ngu·ªìn kh√°ch, Th·ªùi gian t·∫°o, L·ªãch h·∫πn h√¥m nay, Thao t√°c

**ADD new columns:**

#### A. Type Badge (after M√£ KH)

```tsx
{
  title: "Lo·∫°i",
  key: "type",
  width: 80,
  render: (_, r) => (
    <Tag color={r.type === "LEAD" ? "orange" : "blue"}>
      {r.type === "LEAD" ? "LEAD" : "KH"}
    </Tag>
  ),
}
```

#### B. First Visit Date (after Th·ªùi gian t·∫°o)

```tsx
{
  title: "Ng√†y kh√°m ƒë·∫ßu",
  key: "firstVisitDate",
  width: 120,
  render: (_, r) =>
    r.firstVisitDate
      ? dayjs(r.firstVisitDate).format("DD/MM/YYYY")
      : "‚Äî",
}
```

#### C. Update Customer Code (handle NULL for LEADs)

```tsx
{
  title: "M√£ KH",
  dataIndex: "customerCode",
  key: "customerCode",
  width: 140,
  render: (code, r) => {
    if (r.type === "LEAD") return "‚Äî"; // LEADs don't have code
    return code || "‚Äî";
  },
}
```

---

### 3. Customer Detail View Updates

**File:** `src/features/customers/views/CustomerDetailView.tsx` (to be created)

**ADD:**

#### A. Type Badge in Header

```tsx
<PageHeader
  title={
    <>
      {customer.fullName}
      <Tag color={customer.type === "LEAD" ? "orange" : "blue"}>
        {customer.type === "LEAD" ? "LEAD" : "KH√ÅCH H√ÄNG"}
      </Tag>
    </>
  }
/>
```

#### B. Convert Button (only if type=LEAD)

```tsx
{
  customer.type === "LEAD" && (
    <Button type="primary" onClick={() => setShowConvertModal(true)}>
      Chuy·ªÉn th√†nh Kh√°ch h√†ng
    </Button>
  );
}
```

#### C. First Visit Date in Info Section

```tsx
<Descriptions.Item label="Ng√†y kh√°m ƒë·∫ßu">
  {customer.firstVisitDate
    ? dayjs(customer.firstVisitDate).format("DD/MM/YYYY")
    : "Ch∆∞a kh√°m"}
</Descriptions.Item>
```

---

## üß™ TESTING

### Unit Tests

**File:** `customer.service.test.ts`

**Add:**

```typescript
describe("CustomerService - Lead Integration", () => {
  it("should set firstVisitDate on create", async () => {
    const customer = await customerService.create(user, {
      fullName: "Test User",
      phone: "0912345678",
      clinicId: "clinic-1",
      city: "HCM",
    });

    expect(customer.type).toBe("CUSTOMER");
    expect(customer.firstVisitDate).toBeDefined();
  });

  it("should only return type=CUSTOMER records", async () => {
    const result = await customerService.list(user, {});

    result.items.forEach((customer) => {
      expect(customer.type).toBe("CUSTOMER");
    });
  });
});
```

---

## üì¶ ROLLOUT PLAN

### Phase 1: Database Migration

- [ ] Backup production database
- [ ] Run migration: Add `type`, `note`, `firstVisitDate` to Customer
- [ ] Set all existing records to `type="CUSTOMER"`
- [ ] Set `firstVisitDate` for existing customers

**Verification:**

```sql
-- Check type field
SELECT type, COUNT(*) FROM "Customer" GROUP BY type;

-- Check firstVisitDate
SELECT COUNT(*) FROM "Customer" WHERE "type" = 'CUSTOMER' AND "firstVisitDate" IS NULL;
```

### Phase 2: Backend Updates

- [ ] Update Customer validation schemas
- [ ] Update Customer repo (add type filters)
- [ ] Update Customer service (set firstVisitDate)
- [ ] Run tests
- [ ] Deploy backend

### Phase 3: Frontend Updates

- [ ] Create ConvertLeadModal component
- [ ] Update CustomerTable (add columns)
- [ ] Update CustomerDetailView (add type badge, convert button)
- [ ] Deploy frontend

### Phase 4: Testing

- [ ] Test existing customer workflows (should work unchanged)
- [ ] Test convert Lead to Customer workflow
- [ ] Monitor logs

---

## üìã IMPLEMENTATION CHECKLIST

**Database:**

- [ ] Schema migration (type, note, firstVisitDate)
- [ ] Data migration (set existing records to CUSTOMER)
- [ ] Verify indexes

**Backend:**

- [ ] Update Customer validation schemas
- [ ] Update Customer repo (all methods)
- [ ] Update Customer service (create method)
- [ ] Run unit tests

**Frontend:**

- [ ] ConvertLeadModal component
- [ ] CustomerTable column updates
- [ ] CustomerDetailView updates
- [ ] Test UI flows

**Deployment:**

- [ ] Deploy to staging
- [ ] Test all workflows
- [ ] Deploy to production
- [ ] Monitor logs

---

## üöÄ SUMMARY

**Impact:** Minimal changes to existing Customer feature

**Key Changes:**

1. Database: Add 3 fields (type, note, firstVisitDate)
2. Backend: Add type filters, set firstVisitDate on create
3. Frontend: Convert modal, table columns, detail view updates

**Estimated time:** 1-2 days

**Dependencies:** Must be deployed BEFORE Lead feature (120 Lead.md)
